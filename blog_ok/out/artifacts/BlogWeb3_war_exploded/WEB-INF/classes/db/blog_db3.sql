/*
 Navicat Premium Data Transfer

 Source Server         : mysql8@local
 Source Server Type    : MySQL
 Source Server Version : 80011
 Source Host           : localhost:3306
 Source Schema         : blog_db

 Target Server Type    : MySQL
 Target Server Version : 80011
 File Encoding         : 65001

 Date: 17/12/2019 23:46:33
*/

SET NAMES utf8mb4;
SET FOREIGN_KEY_CHECKS = 0;

-- ----------------------------
-- Table structure for articles
-- ----------------------------
DROP TABLE IF EXISTS `articles`;
CREATE TABLE `articles`  (
  `id` int(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `author` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `title` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `contents` text CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL,
  `create_at` datetime(0) NULL DEFAULT NULL,
  `updated_at` datetime(0) NULL DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP(0),
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 12 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of articles
-- ----------------------------
INSERT INTO `articles` VALUES (1, NULL, '基于容器的微服务架构技术选型与设计', '<h2>背景介绍</h2><p>作为金融企业，国投瑞银基金多年以来 IT 工作主要还是以运维为主，主要业务系统基本采用外购模式，但随着业务的不断发展，业务部门个性化需求越积越多，外购与外包已经不能很好满足业务员部门的需要了。2016 年底公司着手开发团队的组建工作，同时对公司的业务开发平台进行架构选型与设计，以求统一开发平台，提升研发效率，从而加快业务部门的业务需求处理效率。</p><p>下面我们将就这两年在平台架构选型、平台架构设计、平台及相关子系统的逐步完善背后的一些经验进行分享。</p><h3>适用对象</h3><p>该架构全部基于开源平台，经过三年多的生产上线实践，平台运行平稳，可扩展性强，可用性高，可以很好满足公司对于金融业务不断发展的需要，这对类似的中小型企业的业务架构选型也具有一定的参考意义。</p><blockquote>注：UFOS：国投瑞银基金运营系统</blockquote><h2>架构设计与选型</h2><h3>架构设计考量因素</h3><p>在初期平台<a href=\"https://s.geekbang.org/search/c=2/k=%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/t=\" target=\"_blank\">架构设计</a>与选型时，我们根据现有业务系统的需求，梳理出了技术架构选型需要考量关键因素：</p><ol><li>架构平台的前瞻性或先进性，符合当前潮流与未来发展趋势，有较好的生态链和较强的生命力，不能因为平台架构选型不当，导致未来平台重新架构，造成大量的迁移和重构工作，需保障平台架构能在一段时间内保持技术领先。这里有两点注意，一是对技术成熟度的考量，是否采用有风险的前沿技术以及拥抱这种技术带来的风险，这一点类似于金融投资中收益与风险的关系，我们需要在系统的先进性与系统的稳定性之间进行平衡；二是采用前沿技术可能会面对更多的困难，如国内可能缺乏相关资料，或难以找到可以参考的成功案例，很多时候只能通过官方和论坛获取相关技术信息，会对架构按时交付带来风险。</li><li>平台的<a href=\"https://s.geekbang.org/search/c=2/k=%E5%8F%AF%E6%89%A9%E5%B1%95%E6%80%A7/t=\" target=\"_blank\">可扩展性</a>能满足基金行业业务不断的发展与创新的需求，尽量能做到平台的横向平滑扩展，满足以上特性其实就决定了架构的分布式特性，当然我们更希望它是云原生的架构</li><li>系统的<a href=\"https://s.geekbang.org/search/c=2/k=%E5%8F%AF%E9%9D%A0%E6%80%A7/t=\" target=\"_blank\">可靠性</a>和<a href=\"https://s.geekbang.org/search/c=2/k=%E5%8F%AF%E7%94%A8%E6%80%A7/t=\" target=\"_blank\">可用性</a>作为金融业务系统平台，需保证业务系统连续不间断运行，保证平台的高可用。采用集群或平台自动恢复功能，确保平台局部出错也不影响系统整体的运行；这里有两个层面，一是业务系统中的功能组件能相互隔离，其中一个组件的不可用不能影响到系统的其他部分；二是平台基础系统采用集群架构，有自动恢复功能，确保即使系统中有节点出错，也可在很短时间内完成出错节点中服务的切换与恢复</li><li>开销不同的架构 / 技术选择有着不同的开发成本，包括技术框架，平台的学习成本，我们期望平台能支持异构的技术，使得开发人员可以采用比较适合的技术栈来快速实现业务功能的开发</li><li>开发运维一体化思想（<a href=\"https://s.geekbang.org/search/c=2/k=DevOps/t=\" target=\"_blank\">&nbsp;DevOps&nbsp;</a>），在设计时考虑运维，尽量减少后期运维操作的复杂度，减轻后期业务系统运维的负担。</li><li>让开发人员更多专注在业务功能需求开发，其它非功能需求如负载均衡、高可用等尽量由平台提供，做到对开发人员透明，以提升开发效率。</li></ol><p>当公司规模不大，实力不足以自己实现部分或全部架构，选择现成的“轮子”来组装自己的架构就成了一种自然的选择。在选择上可能会更多考虑如何使用更“标准”的“轮子”来满足自己业务的需求，以便于今后业务的升级和扩展。</p><p>要实现上述平台的扩展性和高可用性，一般都离不开分布式架构，而分布式架构一般离不开服务来承载 。</p><h3>基于服务架构演进</h3><p>基于服务的架构设计早已有之，比如基于 RPC 的服务调用，最早可追溯到 CORBA，以及现在还有很多金融公司在交易系统中使用的 BEA 早期的框架 Tuxedo（主要编程语言为 C/C++）。后来者有 Facebook 的 Thrift，Google Protocolbuf 框架 /grpc，阿里的 Dubbo 框架等等。这些框架支持消息的二进制编码（序列化与反序列化），效率高，因此成了对网络传输，并发处理要求高的应用如 App 应用，游戏，交易软件等的首选。</p><p>后来随着 HTTP 协议的广泛应用，发展衍生出面向服务的架构（SOA）的架构设计，该架构一般都应用在比较复杂，大型项目中，为了异构系统中的功能复用，或系统性能的考量将功能模块独立出来成为服务，服务可以分布式部署，服务之间通过标准的软件接口方式在网络中相互调用；为了统一服务调用标准，SOA 往往还引入了数据总线概念，服务可以通过数据总线进行服务注册，服务的查找与调度。</p><p><a href=\"https://s.geekbang.org/search/c=2/k=SOA/t=\" target=\"_blank\">SOA&nbsp;</a>架构中的服务之间是松耦合的，服务的颗粒度相对比较粗，而近些年出现的微服务，则可以看作是对 SOA 服务的一种精简，细化，或者说是 SOA 服务的轻量版。</p><h3>微服务</h3><p>在谈及<a href=\"https://s.geekbang.org/search/c=2/k=%E5%BE%AE%E6%9C%8D%E5%8A%A1/t=\" target=\"_blank\">微服务</a>的时候，大都会对应到单体应用，以示鲜明对比；单体应用其实就是一个服务中包含了太多种功能的应用，它跟面向对象的设计里的单体类（包含太多功能实现的类）的提法颇有些类似，英文单词中有一个专有名词 monolithic 来描述二者：</p><p><img src=\"https://static001.infoq.cn/resource/image/3e/2d/3edb8efa591736822e086b8bca63402d.png\" alt=\"基于容器的微服务架构技术选型与设计\"></p><p>如果你再仔细对照微服务和类，你会发现两者有诸多相似之处，比如微服务和类在设计原则上也是一致的，也就是高内聚 / 封装与松耦合，高内聚也就是只负责一项任务，也就是单一职责原则，而松耦合则是指模块之间的接口尽量简单，减少耦合度，这样也使得开发，独立部署和升级微服务更加容易。</p><p><img src=\"https://static001.infoq.cn/resource/image/99/1e/999ca899cb1e68a9cc7861ba0222d41e.png\" alt=\"基于容器的微服务架构技术选型与设计\"></p><p>微服务同时也很好地匹配了敏捷开发团队，减少了开发团队的沟通成本，更小的代码库同时有效降低了开发团队之间的冲突，使得小团队开发更加有效。</p><h3>微服务框架选型</h3><p>2016 年，当时的微服务还不像在现在的市场上一样炙手可热，当时微服务兴起不算太久，在互联网企业有早行者，但市场整体上参考资料与可参考的案例相对并不多，市场上对选型微服务架构也不是太明朗。但对照前面架构选型的各种考量因素，微服务还是非常匹配我们的选型标准的，而且能与我们小团队敏捷开发的组织架构相匹配，因而微服务架构基本成为了我们架构中的首选。</p><p>既然选择了微服务，接下来的工作就是微服务框架的选型，选型中我们主要考量的因素是：</p><ol><li>编程语言，编程语言需要考虑现有开发人员的技术栈和语言的流行度，以及其生态</li><li>框架的生态链，比如安全，服务注册，服务发现与监控等等</li></ol><p>我们列出了当时市面上比较流行的微服务框架候选者：</p><ul><li>基于 RPC 协议的框架，如阿里的<a href=\"https://s.geekbang.org/search/c=2/k=Dubbo/t=\" target=\"_blank\">&nbsp;Dubbo&nbsp;</a>框架，在国内电商，物流，金融软件等行业都有较多的应用场景，还有 Java RMI，Apache Thrift 和 Google grpc</li><li>基于<a href=\"https://s.geekbang.org/search/c=2/k=Spring%20Cloud/t=\" target=\"_blank\">&nbsp;Spring Cloud&nbsp;</a>Java 微服务框架</li><li>基于容器的微服务框架</li></ul><p>当时微服务兴起不久，市场框架选择并不是太明朗，Spring Cloud 当时也在不断地演进与完善中，Dubbo 已经停止更新，但相对来说，国内市面上这两者的选择比较多，微服务开发的主流语言也是 Java。</p><p>通过对比和调研我们最终选择了基于容器的微服务方案，这主要是基于：</p><ul><li>微服务设计中有一个比较的重要原则是，技术异构性，可以使用与需求比较匹配的语言和相关的数据存储方案，而不限于哪种编程语言和哪一种统一的数据库来实现微服务的开发。比如对于数据分析型微服务，你可以采用 Python；对于性能有要求的微服务，你可以采用 Go 或者 C++ 进行开发，底层数据存储也不限于 RDBMS，可以使用 NoSQL，嵌入式数据库，这使得我们可以更快地使用新技术。基于容器的方案可以很好的满足以上微服务设计的需求，每个容器运行一个微服务，微服务之间通过协议实现互联，众多微服务组合起来组成一个大的完整的应用系统；而 Dubbo 和 Spring Cloud 基本就是捆绑在了 Java 语言平台。</li><li>基于容器云原生方案，微服务的平台更宽泛，可以选择基于云的部署方案。</li><li>微服务容器基于标准的容器基础镜像构建，这样容器的运行环境统一，便于统一管理，也便于排查问题。</li><li>由于容器的标准化，容器平台可以通过容器提供标准的服务注册，服务负载均衡，服务监控，服务的 failover 机制等，而这些都不需要植入源码，可以最大限度让开发人员专注于业务的开发。</li></ul><p>开发语言我们还是选定了主流的 Java，即使我们有一些历史遗留的 C#项目，Java 毕竟是编程语言的排头兵，也是开源的主力军，有很多的开源“轮子”使用，可以大大加快开发进程，即使其编译后的执行包偏大（几十到近百兆，虽然自 Java 9 的模块化编程有所改善），但对我们的业务平台相对来说并没有多大影响。</p><p>Java 框架我们选择了 Spring Boot，它在 Spring MVC 基础上简化了配置管理，也有多种 starter，简化了编程，可以快速搭建微服务应用。</p><h4>微服务间前端框架选型</h4><p>架构前期，由于人力有限，我们并未对微服务前端框架进行选型，更多是依赖外包开发商的现成框架，比如第一个项目的几个微服务就是采用的是基于 jQuery 的框架；第二个项目的开发商采用的是 vue.js，并基于 vue.js 进行了组件包装（尚未完全完工），不过该组件包装需要额外付费。由于我们对外包方包装的组件信心不是很足，因为包装的组件基本没有测试用例，这迫使我们下定决心进行前端选型，这也有利于后续业务开发的一致性与可维护性，保证应用研发的质量。</p><p>随后我们花了两个多星期对市面上的前端主流框架进行了初略快速的选型，并做了 Demo，最终 Google 公司当年的前端新品 Angular 2 框架被采纳。一是 AngularJS 受众大，这次 Google 团队不兼容重新设计也从 AngularJS 1.x 吸取了大量的经验，并结合近年来新的 Web 的进化和前端开发尤其是移动方面的变革，运用全新的思路进行重新架构，精简了 1.x 的概念与指令，并利用单向数据流，服务端渲染机制等大大提升框架性能；二是 Angular 支持组件式开发，并支持 TypeScript，TypeScript 吸收了许多面向对象的编程语言优势，跟后端语言更接近，使得后端人员上手前端开发比较容易。我们的开发人员通过 Demo 的学习与服务的前后端一体化指导开发，很快就成为前后端一体开发的全栈开发工程师。</p><p>后续 Angular 的高速发展印证我们选择还是正确的，对于自身没有很强研发实力的，选择正确的框架还是非常重要的，尤其是大厂商的产品，因为其周边的生态也会日趋完善，产品生命周期更长久（慎用小开发商的产品，对开发中组件的引入最好也要做好审批）。</p><p>在 Angular 之上我们选择了开源的 PrimyNG 组件套件以简化前端开发，PrimeNG&nbsp;是一个极为完善的开源 Angular UI 组件库，现在已经发展到 80 多个组件，基本可满足我们业务开发中的所有&nbsp;UI 需求，虽然当时的版本还偶有 Bug 或功能未完善的组件。现在，我们的前端已经形成了一套比较成熟的开发模板，可以快速完成微服务前端模块的搭建。</p><p>当然，在 Angular 上还有其他一些成熟的开源组件平台可以选择，比如官方的 Material 和阿里的 NG-ZERO 组件等。</p><h3>微服务通信</h3><p>运行中的微服务实例其实就是一个个的进程，它们可以在网络中分布式部署，微服务调用涉及到网络之间数据的交换，其实也就是数据对象的序列化与反序列化。</p><p>RPC 框架通常有自己的接口描述语言（Interface Definition Language，IDL），框架提供工具可以将 IDL 生成服务端和客户端的 stub，stub 可以实现消息序列化与反序列化，以便于数据消息对象通过网络在客户端与微服务之间传输。由于 RPC 框架支持二进制编码方式进行序列化，因此传输效率更高，可以获得更高的性能和更低的延迟；而且相对纯文本方式的数据传输，数据安全性更高。为增加安全性，一般这种编码还会设计相应的数据头，以便于对主体数据进行加密与签名。</p><p>RPC 通信由于双边需要 stub，更多用在有独立客户端的情况如 Client/Server 模式下，很多还受限于具体框架支持的语言，也与平台相关（比如很多本质上是基于二进制，有的对大端字节顺序的平台可能就不支持），因此选用和语言和平台无关的通信协议是一种更好的方式。</p><p>RESTful API 是基于超文本传输协议 HTTP 之上一种架构设计风格，当时已经在 Web 应用开发中比较流行了，它通过 URI 来唯一定位一个需要操作的资源，而使用标准的 HTTP 方法来完成对资源的 CURD 操作，这种设计简洁，轻量，易用。URI 中的数据传输简单的可以采用 Key/Value 的形式，复杂的可以采用 JSON 数据格式，后者在诸多编程语言中可以方便实现数据的序列化和反序列化。</p><p>选择开放标准的传输协议，其上的生态链更丰富。我们微服务平台架构选择了当时流行的 B/S 架构模式，RESTful API 就成为我们一种自然的选择，结合 SpringBoot 框架，它给我们带来以下好处：</p><ol><li>编程简单，SpringBoot 的 Controller 可以方便直接获取 HTTP 中的参数对象，前端的 TypeScript 也可以直接映射到对象。</li><li>调试和测试比较轻松，毕竟 URI 中的参数都是文本编码可见，可以方便结合测试工具进行接口测试，比如 Postman；我们的平台也集成了 Swagger API，可以直接在 Swagger 界面上直接进行测试。</li></ol><p>除了基于 REST API 方式的数据交换以外，我们在设计规范中也规定了其他的 RPC 通信模式，比如 Thrift 和 Protocolbuf，当遇到以下场景可以考虑使用：</p><ul><li>对性能有要求的微服务。</li><li>有异种语言之间通信，而另外一种语言标准中对基于 HTTP 通信协议支持不是很好，例如在我们的传真微服务开发中，我们就使用了 Protocolbuf 协议，传真服务采用 C++ 开发，Java 客户端通过消息队列异步与后端的传真服务通信。</li></ul><h4>微服务间的交互模式</h4><p>RESTful API 微服务调用一般都采用请求 / 响应的同步模式（单向通知除外），如果需要进行异步的 API 调用，比如有些耗时的请求，客户端一直阻塞等待响应可能不是一种好的处理方式，采用异步处理方式有：</p><ul><li>大多数 RPC 框架都提供异步调用机制，如 Thrift 与 grpc，通常它与同步调用区别在于调用返回的不是结果，而是一个句柄，该句柄可以用于随后的结果获取。</li><li>使用一些高级语言的同步控制机制，比如使用 future 与相关的 Provider，处理机制与第一种方式比较类似。</li><li>采用异步的消息通信机制，客户端通过向服务端发送消息提交请求。如果服务端需要回复，则会发送另外一个独立的消息给客户端，消息通信一般通过独立的消息队列实现，经常使用的消息队列包括 RabbitMQ，ActiveMQ。</li></ul><h4>消息系统</h4><p>消息系统使用方式通常有以下几种方式：</p><ol><li>消息队列模式。</li><li>发布、订阅模式。</li><li>消息路由模式。</li><li>主题（Topic）消息订阅。</li><li>RPC 模式，可以理解为异步远程过程。</li></ol><p>采用消息机制的优点：</p><ul><li>解耦客户端和服务端：客户端只需要将消息发送到正确的 channel，客户端完全不需要了解后端具体的服务实例，更不需要一个发现机制来确定服务实例的位置。</li><li>消息缓存，不需要像同步调用，必须保证所有的客户端和服务端在交互期间保持可用，即使是服务端处理不过来，客户端依然可以发送请求。</li></ul><p>消息机制的缺点：</p><ul><li>增加了操作系统的复杂性：需要安装、配置和部署消息系统，消息 broker（代理）必须保证高可用，否则系统可靠性将会受到影响。</li><li>增加了编程的复杂性，消息驱动开发的代码比较难以理解和维护。</li></ul><h5>消息系统选型</h5><p>根据业务需求，我们对消息系统的选型更侧重在可靠性，其他方面如吞吐量等并无更多的特别要求，市面上有较多成熟的消息系统可以选择，在金融系统中，RabbitMQ 就因其较强的扩展性，较高的可靠性和可用性被广泛使用，ActiveMQ 也有不少使用案例。</p><p>ActiveMQ 是基于 JMS 实现的消息系统，它主要提供了两种类型的消息：点对点以及发布 / 订阅。它是一个高可靠性、高性能和可扩展的消息系统，支持消息标准协议，例如 AMQP（1.0 标准）和 STOMP，官方支持多种编程语言，包括经常使用的 Java, C++（RabbitMQ 官方并不提供 C++ 编程语言包，而我们在平台中规划了 C++ 应用比如传真微服务）和 Python， ActiveMQ 可以很好满足现有业务的需求，最终我们选择了 ActiveMQ 作为我们消息系统。</p><h3>服务发现与部署</h3><p>设想一下，微服务按照我们上面所述通信方式提供了 REST API 或者 RPC 接口调用，为了完成一次服务请求，调用方需要知道服务实例的网络位置（IP 地址和端口）。传统应用都运行在物理硬件上，服务实例的网络位置都是相对固定的（DNS 或者静态 IP 地址）。而对于一个现代的，基于云部署的微服务应用来说，这却是一个很麻烦的问题，服务实例的网络位置都是动态分配的，而且因为扩展、失效和升级等需求，服务实例会经常动态改变，因此，客户端代码需要使用一种更加复杂的服务发现机制。</p><p>在我们的架构设计中，我们选择了容器作为微服务的载体。其设计思路就是把一个微服务装入一个容器中，也就是一个容器中运行一个微服务，微服务通过容器对外提供服务接口调用；而容器作为一种标准构件，非常容易在网络中实现管理和监控；服务的发现和注册可以通过容器相关技术来实现，这会用到容器的编排与管理技术。</p><p>当时在容器市场上，Docker 可谓一枝独秀，但容器编排还处在一片混战中，局势并不是太明朗，市面上流行的编排方案有 Kubernetes，Mesos 和 Docker Swarm 等，Docker Swarm 是由 Docker 容器厂商创建的集群工具，它对外提供的是完全标准的 Docker API，可以与 Docker 引擎无缝集成，任何使用 Docker API 与 Docker 进行通讯的工具（Docker CLI, Docker Compose）都可以完全无缝地和 Docker Swarm 协同工作，因此 Docker 的经验也可以继承过来，非常容易上手，学习曲线和二次开发成本相对 Kubernetes 都比较低。同时 Docker Swarm 本身专注于 Docker 集群管理（Kubernetes 对容器管理进行了抽象，支持 Docker，rtk 等），非常轻量，占用资源也非常少，运行效率也高，也有支持几千个容器的集群案例。</p><p>虽然 Kubernetes 发展势头更猛，根据项目需求和公司研发实力，我们最终还是选择了能更快实施与部署的 Docker Swarm 方案（当然到了 2017 年中，容器编排之争基本落下帷幕，最新统计 Kubernetes 占据了 75% 以上市场，Docker Swarm 从曾经的三成已经减少到了个位数）。</p><p>Docker Swarm 在版本 1.12 之前是一个独立的项目叫 Swarm Standalone，这也是我们使用的第一个版本，它的服务发现依赖于外部的 k/v 存储，我们按官方指引选用了 Consul 集群；Swarm 也是独立的进程，需要独立安装，我们采用了容器模式运行 Swarm 进程。</p><p>版本 1.12 后 Docker Swarm 升级为 Swarm Mode，Swarm 也合并到了 Docker 引擎之中，也就是安装了 Docker 引擎 Swarm 服务（内置安全认证，服务发现，负载均衡，集群放置在内置的 datastore 的 meta data，调度，容器网络）就已经在那里了，不需要额外安装，你所需要的只是创建集群。</p><p>Swarm Mode 内置的服务发现是通过每个节点 Docker 引擎内置的 DNS Server 来实现，在集群中创建的服务都会在相应的节点的 DNS Server 进行登记，各节点的 DNS Server 之间通过 gossip 协议进行信息交换；每个服务都有一个 DNS 解析器，它将 DNS 查询转发到节点 Docker 引擎，由 DNS Server 来进行解析， 如果不能解析则转发到配置的外部 DNS Server，这样服务在集群中任意节点就可以相互访问了。</p><p>服务的负载均衡（LB）缺省是通过虚 IP（VIP，使用微服务的服务名）或一组服务的 IP（tasks. 服务名）根据内置的 IPVS 来实现，也可以在创建服务的时候指定 dnsrr 模式通过 round-robin 轮询来实现。</p><p>就 Swarm Mode 集群本身来说，安装比 Swarm Standalone 简单了不少，升级和移植也比较简单。通过近 3 年多我们业务系统生产的营运实践表明，Docker Swarm 可以说完美满足我们的现有业务平台的需要，包括其稳定性，集群的高可用性（包括容器自我检测与自动重启，错误节点中的容器自动转移）和可扩展性（包括集群节点的动态扩容，容器服务的实例动态扩充），也可以满足业务未来多年发展的需要。</p><p><img src=\"https://static001.infoq.cn/resource/image/8c/53/8c0f5ae8aaa1cbee5c236c2a3949d453.png\" alt=\"基于容器的微服务架构技术选型与设计\"></p><center>Figure 1: Docker Swarm 服务发现与负载均衡</center><h3>HTTP 反向代理 / 服务网关</h3><p>微服务除了内部相互之间调用和通信之外，最终要以某种方式暴露出去，才能让外界系统（例如 Web 应用、移动应用等）访问到，这就涉及服务的前端路由，它是连接内部微服务和外部应用系统的一个通道。</p><p>HaProxy 与 Ngix 等工具也可以实现 HTTP 反向代理，但基于以下特性，开源的 HTTP 反向代理与负载均衡工具 Traefik 成为我们的最终选择：</p><ol><li>Traefik 更适合需要服务发现和服务注册的应用场景，它 支持多种后台应用自动发现，如 Docker，Swarm，Kubernetes，Consul 等，它还可以动态监测后台服务的变动以自动实时更新自己的配置。</li><li>支持限流与自动熔断功能。</li><li>支持配置热更新。</li></ol><p>可以说 Traefik 非常适合容器化的微服务，采用 Traefik 可以带来以下好处：</p><ol><li>服务反向路由，Traefik 将外部请求反向路由到内部具体的微服务，这样虽然系统平台内部是复杂的分布式微服务架构，但是外部系统从代理上看到的就像是一个统一的完整服务，代理屏蔽了后台服务的复杂性（类似 Facade 模式），同时也可以屏蔽后台服务的升级和变化。</li><li>便于安全控制，服务通过代理统一访问后端的微服务，而代理访问微服务是通过容器内部网络进行，也就是微服务都可以不用暴露端口到容器外端，外部应用也就不能直接访问容器里边的微服务了，而必须通过 Traefik 代理。代理有微服务的注册信息，它可以根据微服务名正确路由到相应的 IP/ 端口的微服务容器。这样我们的安全策略就只需要集中在 Traefik 代理端控制即可。</li><li>提供多种格式度量数据，比如可以提供我们采用的 Prometheus 监控数据格式，提供访问量，调用延迟，错误计数等数据，为后端的性能优化或者扩容提供数据支持。</li></ol><p><img src=\"https://static001.infoq.cn/resource/image/7b/77/7bfcf3ac22eb7351699c3b99d94a2677.png\" alt=\"基于容器的微服务架构技术选型与设计\"></p><center>Figure 2: HTTP 反向代理</center><h3>日志子系统</h3><p>由于采用分布式架构，并且使用容器来承载微服务，如果使用本地日志文件模式，日志就散落在各个容器内部或各个宿主机上了，这样不利于日志的统一管理和使用，因此，采用一个集中的日志系统中心，也就成了一个必然的选择。</p><p><img src=\"https://static001.infoq.cn/resource/image/45/63/45632bf11bb96a6dd73bf8efa1b82c63.png\" alt=\"基于容器的微服务架构技术选型与设计\"></p><center>Figure 3: 日志子系统</center><p>在我们的架构选型中，我们选择了流行的开源框架 ELK 栈；日志写入远端的 Elasticsearch，通常可以采用两种方式，一种方式是通过日志代理，如 Elasticsearch 提供的高效的 Beats 工具，可以将 Beats 与业务服务部署在一起，这适合第三方服务（没有源码）或开发语言无标准日志组件的服务。而另外一种方式则是通过日志的 SocketAppender，直接将日志通过网络写入远程的日志服务，如 LogStash，很多标准的日志组件都支持这种方式，如 Java 标准日志输出如 Log4j，Logback 等。这种方式也比较适合在容器中部署的微服务，不需要额外再部署另外的日志工具。在我们微服务平台中，日志输出我们选用了性能较高的 Logback，并选用了与之配套的 LogStash 输出插件，通过该插件（代理）Logback 可以将日志通过 Socket 直接输出到 Logstash 服务，而这毋须对代码做任何改动，仅需要通过简单的配置文件配置即可方便实现，对调用日志的应用微服务完全透明。</p><p>为便于后续的日志查找和 Kibana 中的日志数据展示 我们需要对日志的格式进行规范化，以便将日志中的关键信息以键值对的方式存入 ElasticSearch，规范化涉及到日志文本的编码与解码，分别在应用端和 LogStash 端，LogStash 服务可以通过配置来对消息进行 Mapping 和过滤。</p><p>如果日志量比较大，则需要在日志输出与 LogStash 中间增加消息缓冲，Kafka 是一个高吞吐量的消息系统，Log4j2 有直接输出到 Kafka 的 Appender。</p><h3>监控子系统</h3><p>监控系统是平台服务治理中的一个重要组成部分，没有监控的应用系统可以称作一个裸奔的系统；我们原有的业务平台已经有了一套传统的监控系统 Netgain，但更多是对基础设施的监控，缺乏对应用系统内部状态的真正监控，比如对微服务和容器的支持，不能很好满足 UFOS 微服务平台的需求。</p><p>Prometheus 作为从 CNCF 毕业的第二个开源项目（第一个是容器编排项目 Kurbernetes，Prometheus 本来也是源自 Google 对 Kurbernetes 的监控），它能很好地监控服务以及容器，除了能与 Kurbernetes 无缝集成以外，也可以与 Swarm 很好地集成，尤其是配合 Docker Swarm 中的 label 与 global 配置选项使用，可以非常方便实施远程应用监控代理（exporter）的部署。</p><p>由于 Prometheus 是一个开放的监控平台，因此有大量的官方及第三方的监控代理 Exporter（监控代理可以协助不支持 Prometheus 数据采集接口的第三方服务公开自身的监控数据），在 UFOS 中主要使用了以下监控 / 代理：</p><p><img src=\"https://static001.infoq.cn/resource/image/ac/64/ace1f314d422cc92b62c17a56b226664.png\" alt=\"基于容器的微服务架构技术选型与设计\"></p><p>其中 BlackBox 采用的是非代理模式，由于已有 netgain 做基础设施监控，所以并未使用 SNMP Exporter。</p><p>Prometheus 本身也提供了告警服务模块 AlertManager，你可以通过基于 Prometheus 内置的强大的查询语言 PromQL 来设置告警规则，Prometheus 会根据设定的时间间隔从配置好的服务收集度量指标，如果某个指标与定义好的规则匹配，则触发告警。AlertManager 支持告警分组，告警抑制和静默，告警撤销，告警规则正则表达式匹配，告警模板等功能特点。AlertManager 支持多种告警通知，如邮件，Scribe，Hipchat，Wechat（官方原生支持）等，还支持 web 接口调用，可以通过 webhook 与微服务集成，比如阿里钉钉就可以通过该种方式接入。</p><p><img src=\"https://static001.infoq.cn/resource/image/fc/1b/fc31cb00262c5b285170936ce7c0f71b.png\" alt=\"基于容器的微服务架构技术选型与设计\"></p><center>Figure 4: 监控子系统架构图</center><p>Prometheus 提供多种客户端 API 接口调用库，如官方提供 Java，Python，Go，第三方提供 C++，PHP 等库，通过这些库你可以很方便在你的微服务中植入监控的度量数据（通过微服务 Web 接口，如果是批处理任务，则可以将生成的监控度量数据发送到 PushGateway 服务进行托管），为 Prometheus 服务进程拉取到，这样我们可以方便实现对业务数据的监控。</p><p>监控界面展示使用 Grafana，Grafana 是一个开源的图表可视化系统，支持多种时序数据库如 InfluxDB，当然也支持 Prometheus，Grafana 有丰富的图形展示组件，官方网站也提供大量现成的模板，UFOS 中对 Swarm 节点，微服务，数据库，告警等资源进行了监控展示。</p><h3>高可用设计</h3><p>为保障业务的稳定可用，平台应保证持续可用，不会无故宕机，即使出现故障也可以快速发现和定位，通过监控机制，能在系统用户发现之前尽快解决问题，抑或系统能通过设计自动发现故障并进行自动故障转移，比如通过主备或集群的冗余方式来避免单点的问题，这里我们将针对后者，从系统设计来提升系统高可用性进行简要介绍。</p><h4>接入层</h4><p>UFOS 运行平台基于 Linux 系统，平台入口是 HTTP 反向代理 Traefik，为实现入口的高可用，我们必须保证 Traefik 的冗余备份。</p><p>Traefik 本身支持集群方式的 HA 方式，基于配置的 K/V 存储，官方推荐的是 Consul。但是由于我们服务平台是基于 Swarm 集群，Traefik 是以 Swarm 服务方式运行（限制在 Swarm Manager 节点），它可以通过 Swarm Manager 节点读取到足够的 Swarm 中运行的服务实例的相关信息。而 Swarm Manger 之间通过 Raft 算法实时交换信息，因此运行多个独立的 Traefik 实例它们获的服务实例信息是最新也是对等的，所以我们并不需要按官方指引的使用 K/V 存储来实现 Traefik 的高可用。</p><p>为实现 Traefik 的故障自动转移，我们对运行 Traefik Replica 实例的 Swarm Manager 节点设计了基于 VIP 的 Linux 集群方案，使用 Pacemaker+Corosync，其中 Corosync 用于检测节点间通讯是否正常，而 pacemaker 则用于管理集群资源。当检测到 Linux 集群中的任何一台节点故障时 VIP 会自动切换到其他的正常节点，入口也自动切换到该节点上运行的 Traefik 上来，保证 HTTP 访问代理的可用。</p><h4>应用服务层</h4><p>所有的微服务都是以 Swarm 服务的方式运行在 Swarm 容器平台上，微服务的高可用性由 Swarm 提供。Swarm 容器编排系统本身支持高可用，在 UFOS Swarm 集群中配置了三台 Manager 节点（最多可以承受一台 Manager 故障），Manager 之间通过 Raft 进行 Leader 的选举，这种选举保证了单个节点的异常不影响整个 Swarm 集群的运行。</p><p>Swarm 中运行的微服务容器也是高可用的，一是可以通过启动多个相同微服务实例来实现微服务的高可用，Swarm 内部可以通过 VIP 的方式来实现微服务容器之间的负载均衡与故障的无缝切换（VIP 只会转发到健康的服务）。即使是单个微服务容器实例，Swarm 仍能保证微服务的高可用性，如因节点故障，导致节点中运行的微服务容器异常，Swarm Manager 可以自动检测到节点异常，然后把异常节点中的微服务容器，转移到集群中其他健康的节点上去，并在其他节点重启微服务应用，这样仍然可以保证容器中运行的微服务可以被访问，从而实现微服务的高可用性（容器编排技术可以保证容器的动态发现，即使容器被转移到其他节点上重启，从而实现微服务的动态访问，当然这里可能有个延迟，要实现这点还有一个就是需要保证微服务被设计为无状态的）。</p><h4>数据层</h4><p>Oracle Database 采用典范的 RAC 集群，MongoDB 则是基于官方提供的容器镜像，以容器方式实现了三台 MongoDB 的 Replica 配置。</p><p>Redis 采用主从复制模式，配置了一主二从三个节点，同时配置了相等数目的 Redis Sentinel，这些 Sentinel 能共同合作完成故障发现与判断，以及故障转移，并通知应用方，从而实现真正的高可用。</p><p>ActiveMQ 采用官方推荐方式，实现了基于 RDBMS 的主从模式，从消息队列定时从 RDBMS 共享表中检测主消息队列的刷新情况，如主消息队列异常，未能在指定时间内更新，从消息队列提升自己为主消息队列，从而实现主从的切换。这里需要注意的是必须保证主从服务节点的系统时间的同步。</p><p>文件系统的高可用是通过 NFS 文件系统与底层的存储来实现。</p><p>经过生产环境的实践，随着平台的不断完善和运维经验的不断积累，UFOS 平台的可用性已从 99.95% 逐步提升到了 99.99%。</p><h3>微服务整体技术架构</h3><p>以上各小节对微服务平台的各个子系统依次进行了描述，下图是各子系统集成到一起组成的一个完整的微服务平台整体架构图：</p><p><img src=\"https://static001.infoq.cn/resource/image/f3/a6/f350a32f3cff2ee8fcef07c5406beba6.png\" alt=\"基于容器的微服务架构技术选型与设计\"></p><p>Figure 5: 微服务平台整体技术架构图</p><h3>总结</h3><p>该基于容器的微服务架构平台给我们的研发带来了以下益处：</p><p>经过三年多微服务平台运营实践，总结起来该基于容器的微服务架构平台给我们的研发带来以下益处：</p><ol><li>由于完全基于开源系统，可以实现自主可控</li><li>平台基本对于开发人员来说透明，同时 DevOps 使得运维简单，有效提升了研发效率，节省了人力资源方面的投入</li><li>平台微服务开发语言选择更具弹性，现在平台中已有三种语言开发的微服务，而且平台还可以根据开发语言的发展进行语言的更迭，也可以根据市场的变化对开发语言进行调整，最大限度保护现有投资，以及最佳化未来投入</li><li>实现公司的统一开发服务云平台，可以无缝整合现存的第三方服务商提供的服务，有效利用平台在服务治理方面的资源</li><li>可以方便整合第三方开源软件系统为平台直接使用，为平台提供服务，有效节省开发人力投入</li><li>容器运行环境高度统一，微服务问题可以排除干扰，便于问题分析与排查</li><li>该架构平台运行非常稳定，可用性高，可扩展性强，可以根据业务需要进行动态扩展，可以满足公司业务的未来长期发展的需要，并且技术架构有一定的前瞻性，有效避免了因平台架构选型不当导致后续的平台改造移植造成大量的迁移和重构工作，保护了投资（资源投入，包括人力）。</li></ol><p></p><p>该平台架构可以作为中小企业对微服务平台架构选型的一种参考，当然你可以使用 Kubernetes 替换 Docker Swarm， 毕竟后者成为了小众产品（如果从入手的简洁性，Swarm 依然还是具有吸引力的，几天之类上手），其他子系统的选型也可以作为参考。</p><p><br></p>', '2019-11-09 11:51:07', '2019-11-09 11:51:07');
INSERT INTO `articles` VALUES (2, NULL, '前端基础学习资源', '<h1><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTML\" target=\"_blank\">HTML（超文本标记语言）</a></h1><h1><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/CSS\" target=\"_blank\">CSS（层叠样式表）</a></h1><h1><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP\" target=\"_blank\">HTTP</a></h1><h1><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript\" target=\"_blank\">JavaScript</a></h1>', '2019-11-12 06:32:06', '2019-11-12 06:51:21');
INSERT INTO `articles` VALUES (3, NULL, 'Intellij IDEA 一些不为人知的技巧', '<p>今天又听了 Jetbrains 首席布道师 Hadi 的分享的 Intellij IDEA 使用技巧，说又是是因为之前<a href=\"https://link.jianshu.com?t=http://blog.khotyn.com/blog/2014/10/19/intellij-idea-feature/\" target=\"_blank\">在 QCon 听过一遍</a>，但是这次 Hadi 带来的分享又超出了预期（很多布道师到处讲的东西都差不多），从他的这次分享中学到了不少的东西。</p><p>这篇文章的主要目的是将我觉得非常有用的东西给记录下来，一方面是对自己感受的一个整理，一方面也给其他喜欢文字而不喜欢视频的同学一个参考（推荐大家看 ATIT 的视频，Hadi 都是现场直接演示功能）。</p><blockquote>\r\n注意：这篇文章是基于我目前使用的 Intellij IDEA 版本，2016.3 Ultimate 来写的，快捷键是 Mac OS 10.5+。如果同学们使用其他的版本或者快捷键，请大家注意自行脑补映射，(⊙o⊙)…\r\n</blockquote><h3>关闭 Intellij IDEA 的 Tab 页</h3><p>为什么要关闭 Intellij IDEA 的 Tab 页呢，Tab 页放在那里，当我们每次需要找文件的时候，都先要去 Tab 页瞄一眼，看下在不在 Tab 页，如果在的话，用鼠标点一下。这种操作的效率其实非常慢，更加快速的方式是直接关闭掉 Tab 页的功能：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-c16a7979b8b46e79.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\"></p><p>image</p><p>然后直接用 Command + E 来找到最近访问的文件：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-2c5fdea668e88809.png?imageMogr2/auto-orient/strip|imageView2/2/w/970/format/webp\"></p><p>image</p><p>或者直接用 Command + Shift + E 来访问最近编辑的文件：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-a5604a50a66da594.png?imageMogr2/auto-orient/strip|imageView2/2/w/970/format/webp\"></p><p>image</p><h3>跳到特定文件夹</h3><p>Intellij IDEA 和 Eclipse 都有快速根据类名寻找类，或者根据资源名寻找资源的方式，但是如果我们想找一个文件夹，在 Intellij IDEA 里面，可以输入 /文件夹名 来跳到特定的文件夹（使用 Double Shift 快捷键），截图如下：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-2795c8b9a954d478.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\"></p><p>image</p><h3>快速补全行末分号</h3><p>Java 中，每一个 statement 后面都得加上 ; 号，我们可以在行中任意位置使用快捷键 Command + Shift + Enter 来快速补全分号：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-4b144a0b11ab9688.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\"></p><p>image</p><h3>Rest Client</h3><p>Intellij IDEA 里面内置了一个 Rest Client，大家可以通过 Command + Shift + A，然后搜索 Rest Client 来找到：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-30c48d910294d5fc.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\"></p><p>image</p><p>打开以后，可以看到一个简单的 Rest Client：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-0f14e737cfd0109f.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\"></p><p>image</p><p>之所以说它比较简单是因为个人觉得还是 Postman 更加强大，Postman 的管理功能更加强大，而 Intellij IDEA Rest Client 则缺少这样的能力。</p><h3>Hippie Completion</h3><p>这种自动补全的模式，会选择当前编辑器中适合的单词直接拿过来补全：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-ae7f1da135c9bf48.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\"></p><p>image</p><h3>粘贴版历史</h3><p>如果使用过 Mac 里面的 <a href=\"https://link.jianshu.com?t=https://www.alfredapp.com/\" target=\"_blank\">Alfred</a> 的话，可能大家早就习惯了 Alfred 的粘贴板历史的能力，真是复制粘贴的神器啊。其实 Intellij IDEA 里面也提供了这样的能力，我们可以直接通过 Command + Shift + V 来进行访问历史粘贴板：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-4663d9d2caa47bb1.png?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\"></p><p>image</p><h3>Language Injection</h3><p>大家都知道在 Java 的 String 中编辑有 JSON 的话有多麻烦，各种转义真是让人疯狂，在 Intellij IDEA 中，我们可以直接使用 Intellij IDEA 的 Language Injection 的功能（Alt + Enter）将一个字符串标记为 JSON，就可以非常方便地编写 JSON 了，再也不用担心转义的问题了：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-a1aaed1eeed1bbe4.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\"></p><p>image</p><p>当然，正则表达式也是支持的，甚至支持简单的正则表达式的测试能力：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-23469171daa609c8.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\"></p><p>image</p><h3>Smart Step Into</h3><p>在 Debug 的时候，如果一行代码中有多行语句，我们又需要进入其中的一个方法调用的话，经常做的方法是点开源代码，然后打上断点，或者直接右键 Run to Line，而不能使用快捷键快速将 Debug 的当前行进入到想要去的方法上，Intellij IDEA 提供了 Smart Step Into 的能力，只要使用 Shift + F7，就可以选择到底要 Debug 进入哪一个方法：</p><p><img src=\"//upload-images.jianshu.io/upload_images/134563-ff19d730429acae6.gif?imageMogr2/auto-orient/strip|imageView2/2/w/1200/format/webp\"></p><p>image</p><p>以上就是我从上午的这次 Intellij IDEA 的插件的分享中学习到的一些新的 Intellij IDEA 的使用技巧，拓展了我对 Intellij IDEA 的认知，原来一个 IDE 可以做到这么智能，这么牛逼！</p><p>还在观望是否要使用 Intellij IDEA 的 Eclipse 的小伙伴们，赶紧弃暗投明加入 Intellij IDEA 的队伍吧，O(∩_∩)O哈哈</p><p>蚂蚁金服招聘中间件开发工程师/技术专家，欢迎大家的简历哦：<a href=\"https://link.jianshu.com?t=mailto:khotyn.huangt@alibaba-inc.com\" target=\"_blank\">khotyn.huangt@alibaba-inc.com</a></p><p><br><br></p><p>作者：khotyn</p><p><br></p><p>链接：https://www.jianshu.com/p/364b94a664ff</p><p><br></p><p>来源：简书</p><p><br></p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><br></p>', '2019-11-14 18:33:21', '2019-11-14 18:33:21');
INSERT INTO `articles` VALUES (4, NULL, '着眼语言本身，咱们来聊聊 JavaScript | 极客时间', '<p>JavaScript 和 HTML 、CSS 同属前端工程师必须掌握的三大技能，重要性不言而喻。这几年，随着行业的发展，JavaScript 更是变得无所不能，毫不夸张地说，现在我们看到的基本所有的主流互联网应用，它的前端都有大量的 JavaScript 代码。</p><p>但是，入行 20 多年，我发现很多人对 JavaScript 的印象都只是“简单易学”，对其掌握也仅仅停留在“会用就好”，以至于不求甚解、迷失于 JavaScript 。究其原因，他们从来都只是“写代码”，而没有去真正去了解、去探索“<a href=\"https://time.geekbang.org/column/intro/252?utm_term=zeusHZW4N&utm_source=infoq&amp;utm_medium=website\" target=\"_blank\">什么是语言</a>”。</p><p>其实，JavaScript 作为一门语言，虽然易上手，但却有着诸多复杂微妙的机制，想要真正掌握绝非易事。而这些机制，正是语言的精髓。只有当你深入理解语言内部的实现原理，才能做到无论出现什么新技术、新框架，都能轻松应对。</p><p>这也是为什么我一直认为：每个工程师都应该构建一个语言知识结构。因为，一旦你建立了你的体系性，你对代码的洞察力绝对会随之而提升，让你可以在纷繁的代码中快速找到性能、组织、逻辑等方面的关键所在，并在语言层面给出合理的解释。这就相当于你创建了游戏规则，拥有了“编程游戏”中的上帝视角。你将会有一种切实的、万物如一的操控感。</p><p>在过去的二十年中，我一直不断探索 JavaScript 语言背后的机制：一面研究它的语言精髓，一面做编程实践。在我和极客时间合作的<a href=\"https://time.geekbang.org/column/intro/252?utm_term=zeusHZW4N&amp;utm_source=infoq&amp;utm_medium=website\" target=\"_blank\">《JavaScript 核心原理解析》</a>专栏中，我希望把我找到的答案分享给你。我将以“语言”为核心，和你一起讨论我对 JavaScript 各种语言特性的理解。</p><p>你会发现，这个专栏和其他不同，每一讲的标题都是一行代码，并且，这些代码在表达多种语言特性的同时，都指向一个核心的内容讲述方向。</p><p>我希望通过这个专栏，你能找到自己对语言的认识，构建一个语言知识结构。因为我始终认为，“构造认识”对你是极致重要的事情，并且越早越好。</p><p>也欢迎你在专栏中跟我一起探讨 JavaScript，我会知无不言言无不尽。<img src=\"https://static001.infoq.cn/resource/image/28/62/282fa6d0b5cace0fddad6fbe72a00762.jpg\" alt=\"着眼语言本身，咱们来聊聊 JavaScript | 极客时间\"></p><h2>我是谁？</h2><p>我是周爱民，目前是南潮科技（Ruff）首席架构师。和你一样，我是个喜欢 JavaScript 的人。很多人认识我，可能都是通过我写的《JavaScript 语言精髓与编程实践》一书。</p><p>从业二十多年，我深入研究过 JavaScript、Delphi、Erlang，也专注于软件开发与架构、项目管理，曾担任盛大网络平台架构师、支付宝业务架构师和豌豆荚首席架构师。</p><p>我也特别热爱写作与分享，出过《Delphi 源代码分析》、《大道至简：软件工程实践者的思想》、《大道至易：实践者的思想》、《程序原本》以及《我的架构思想：基本模型、理论与原则》等书。</p><h2>你将获得什么？</h2><p>专栏分为以下 4 个模块。</p><h3>1. 从零开始</h3><p>第一部分我会主要讲述构成 JavaScript 语言的基础——JavaScript 语言的静态结构，主要包括词法环境、块级作用域、语句、声明、字面量、变量环境、模块（名字空间）等等。</p><h3>2. 从表达式到执行引擎</h3><p>第二部分我会主要讲述 JavaScript 的执行过程，包括执行栈、执行队列、执行上下文、函数（函数对象 / 闭包) 作为执行结构如何参与运算等等，还将讲述表达式（运算符 + 操作数）与优先级这个体系，说明表达式运算与语句运算间的不同。</p><h3>3. 从原型到类</h3><p>第三部分我会讲述 JavaScript 面向对象编程体系中最核心的一些设计，包括类继承、原型继承、属性表的使用、内部方法等等，并对索引数组和关联数组在 JavaScript 中的应用与整合做深度的分析。</p><h3>4. 从粗通到精通的进阶之路</h3><p>最后，我会讲述 JavaScript 作为动态语言的主要特性，包括动态的类型、动态的执行过程和动态的环境上下文等等。</p><p>专栏目录👇<img src=\"https://static001.infoq.cn/resource/image/2f/05/2f4a920fdb015cf92fa2a458bd7b3f05.jpg\" alt=\"着眼语言本身，咱们来聊聊 JavaScript | 极客时间\"></p><h3>限时订阅福利</h3><p></p><p>1. 早鸟拼团价 ¥55，原价 ¥68，<a href=\"https://time.geekbang.org/column/intro/252?utm_term=zeusHZW4N&amp;utm_source=infoq&amp;utm_medium=website\" target=\"_blank\">戳我订阅</a>2. 分享海报，邀请好友订阅即可获得&nbsp;¥18 返现，多邀多得，上不封顶。</p><p><br></p>', '2019-11-14 22:35:55', '2019-11-14 22:35:55');
INSERT INTO `articles` VALUES (5, NULL, '简约而不简单的通用错误页面', '<h2>背景</h2><p>线上某个项目由于后端 controller 层代码异常, 没有执行到渲染页面模版, 造成前端 Web 页面展示出来是一个空白的页面，俗称白屏。</p><h2>思考</h2><p>页面出现白屏, 势必需要从头到尾逐步去排查问题, 找到源头和原因</p><ol><li>\r\n确认页面的 HTTP 请求有没有问题\r\n\r\n\r\n如果是 404 了(我们这次的现象就是 404 白屏), 那需要再往后端方向排查问题\r\n\r\n\r\n如果页面内容返回正常, 那很有可能是前端渲染方面的问题, 那就需要往前端方向去排查\r\n\r\n\r\n</li><li>\r\n分析 HTTP 服务器日志, 例如找运维查看 nginx 的访问日志有没有出现异常情况\r\n</li><li>\r\n分析 Application 服务器日志, 例如查看 tomcat 的应用日志有没有出现异常情况。\r\n例如这次问题确定是应用层出现异常产生的 404\r\n</li><li>\r\n最后找到关键代码, 确定问题, 修复上线\r\n</li></ol><p>想想排查问题的流程还是比较长, 比较费时的。如果出现错误时, 不是给一个白屏, 让人去猜哪里出现了问题, 排查一圈才能定位问题, 而是给出明确的错误信息, 有一个明确的错误页面就好多了。</p><h2>设计</h2><p>错误页面是一个通用的需求, 那么我们在设计的时候就应该考虑设计为一个通用的页面, 能够展示任意的错误信息. 即可以通过参数的形式控制页面的展现。</p><p>那么通用错误页面应当具备哪些关键的要素呢? 我们参考各种 404 页面, 抽象之后, 认为关键的三要素如下:</p><ol><li>错误信息: 面向用户的错误提示</li><li>错误码: 面向开发者的错误提示</li><li>引导用户: 出错之后引导用户去\"解决\"这个问题, 避免走入死胡同, 卡死在这里了, 例如显示回退按钮, 引导用户重试</li></ol><h2>实现</h2><p>通过 URL 参数来控制页面的展示和行为：</p><ul><li>\r\nmessage 错误提示, 默认为: 抱歉，出错了\r\n</li><li>\r\nerrorCode 错误码, 默认为: 500\r\n</li><li>\r\nshowPrimaryBtn 是否显示引导按钮, 默认为: true\r\n</li><li>\r\nprimaryBtnText 引导按钮的文案, 默认为: 返回\r\n</li><li>\r\nprimaryBtnAction 引导按钮的动作模式: 回退(history-back), 返回到页面(goto)\r\n</li><li>\r\ngotoUrl 指定 goto 模式时要返回的页面, 默认为: <a target=\"_blank\" href=\"//daojia.com\">//daojia.com</a>\r\n</li></ul><h2>效果展示</h2><figure><img src=\"https://user-gold-cdn.xitu.io/2019/11/14/16e67eec0253c2ae?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><h2>在线demo</h2><ul><li>\r\n<a target=\"_blank\" href=\"https://jz-common-cdn.daojia.com/fe-common-page/error-page/index.html\">适配PC/M</a>\r\n</li><li>\r\n<a target=\"_blank\" href=\"https://jz-common-cdn.daojia.com/fe-common-page/error-page/index.html?message=%E6%88%91%E7%9A%84%E9%94%99%E8%AF%AF%E6%88%91%E5%81%9A%E4%B8%BB&errorCode=1024\">支持自定义错误信息和错误码</a>\r\n</li><li>\r\n<a target=\"_blank\" href=\"https://jz-common-cdn.daojia.com/fe-common-page/error-page/index.html?showPrimaryBtn=false\">支持控制引导按钮是否显示</a>\r\n</li><li>\r\n<a target=\"_blank\" href=\"https://jz-common-cdn.daojia.com/fe-common-page/error-page/index.html?primaryBtnText=%E6%88%91%E7%9A%84%E6%8C%89%E9%92%AE%E6%88%91%E5%81%9A%E4%B8%BB\">支持控制引导按钮的文案</a>\r\n</li><li>\r\n<a target=\"_blank\" href=\"https://jz-common-cdn.daojia.com/fe-common-page/error-page/index.html?primaryBtnAction=goto&gotoUrl=%2F%2Fm.daojia.com%2Fcs%2Fbaomu\">支持控制引导按钮的行为</a>\r\n</li></ul><h2>避免安全风险</h2><ul><li>用于控制页面展示的输入参数(例如 message 参数), 因为是可以任意构造的, 要避免出现 XSS 漏洞就必须转义</li></ul><pre><code>https://jz-common-cdn.daojia.com/fe-common-page/error-page/index.html?message=%3Ch1%3E%E9%94%99%E8%AF%AF%3C%2Fh1%3E\r\n复制代码</code></pre><ul><li>同理 gotoUrl 也是一个可以任意构造的输入参数, 涉及到引导用户跳转, 要避免出现钓鱼风险, 就必须做跳转域名的白名单限制，如</li></ul><pre><code>https://jz-common-cdn.daojia.com/fe-common-page/error-page/index.html?primaryBtnAction=goto&amp;gotoUrl=%2F%2F58.com\r\n复制代码</code></pre><h2>关注我们</h2><p><br></p><p>作者：快狗打车前端团队</p><p><br></p><p>链接：https://juejin.im/post/5dccc5e86fb9a02b550284f1</p><p><br></p><p>来源：掘金</p><p><br></p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><br></p>', '2019-11-15 07:03:06', '2019-11-15 07:03:06');
INSERT INTO `articles` VALUES (6, NULL, '你还没学会javascript原型和原型链吗？', '<h2>前言</h2><p>在前端这块领域，原型与原型链是每一个前端er必须掌握的概念。我们多次在面试或者一些技术博客里面看见这个概念。由此可见，这个玩意对于前端来说有多重要。其实它本身理解起来不难，但是很多刚入行前端的同学，看到prototype、__proto__理解起来还是有点吃力，然后脑子里面就乱成一锅粥，就像我一样。但是这是很正常的事情，没什么大不了的，就像我们想要学会跑步，那么我们就必须先学会走路。任何事情都是有个过程的。所以现在就跟我一起来攻克这个难点吧。通过这篇文章你将掌握以下知识点:</p><ul><li>理解 __proto_;</li><li>理解 prototype;</li><li>理解javascript中对象的概念;</li><li>理解原型和原型链;</li><li>理解javascript中类的概念;</li><li>理解new的实现;</li><li>理解instanceof的实现;</li><li>理解javascript的继承;</li><li>加深对javascript这门语言的理解。</li></ul><p>这也是本篇文章的写作思路。</p><h3>对象</h3><p>那么我们就从对象这一概念开始说起，其实对象这一概念相信大家并不陌生。有一种说法是“javasrcript中万物皆是对象”，其实这个说法是错误的，一个很简单的例子，javasript中简单基本类型（string、boolean、number、null、undefined、symbol）本身就不是对象。其实javasript中对象主要分为函数对象和普通对象。其中:</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Object</li><li>Function</li><li>Array</li><li>Date</li><li>RegExp</li><li>Error</li></ul><p>这些都是函数对象，他们同时也被称为内置对象。函数对象本身其实就是一个纯函数，javascript用他们来模拟类。普通对象就很简单了，就是我们常见的对象:</p><pre><code>const obj = {\r\n    name: \'juefei\',\r\n    desc: \'cool\'\r\n}\r\n复制代码</code></pre><p>可能说到这，你还是无法理解到底啥是函数对象，啥是普通对象，那我们就一起来看看下面的代码:</p><pre><code>const obj1 = {};\r\nconst obj2 = new Object();\r\nfunction func1() {\r\n\r\n}\r\nconst obj3 = new func1();\r\nconst func2 = new function() {\r\n\r\n}\r\nconst func3 = new Function()\r\n复制代码</code></pre><p>接着我们来分别打印一下他们:</p><pre><code>console.log(obj1);  // object\r\nconsole.log(obj2);  // object\r\nconsole.log(obj3);  // object\r\nconsole.log(func1);  // function\r\nconsole.log(func2);  // function\r\nconsole.log(func3);  // function\r\n复制代码</code></pre><p>所以可以看见,obj1、obj2、,obj3是普通对象，他们都是Object的实例，而func1、func2、func3则都是Function的实例，称为函数对象。我们再看看:</p><pre><code>console.log(typeof Object);  //f unction\r\nconsole.log(typeof Function); // function\r\n复制代码</code></pre><p>你是不是惊呆了，原来Object和Function都是 Function的实例。\r\n所以我们得出一个结论就是：</p><ul><li>只要是Function的实例，那就是函数对象，其余则为普通对象。</li></ul><p>同样我们也可以看出，不仅 Object 是函数对象,就连  Function 本身也是函数对象，因为我们通过 console.log(typeof Function); 得知 Function 是 Function 的实例。是不是又开始有点绕了？没事，到这一步你就记住我们刚刚的结论就算完成目标:</p><ul><li>只要是Function的实例，那就是函数对象，其余则为普通对象。</li></ul><p>那么说到对象，我们从上面可以看出，一个对象是通过构造函数 new 出来的，这其实跟原型和原型链有很大的关系，那么原型和原型链到底是用来干嘛的呢？</p><h3>原型</h3><p>涉及到这两个概念，我们就必须先来介绍两个东西: __proto__ 和 prototype ，这两个变量可以说，在 javascript 这门语言里面随处可见，我们不管他三七二十一，我们先来看一张表:</p><table>\r\n<thead>\r\n<tr>\r\n<th>对象类型</th>\r\n<th><code>__proto__</code></th>\r\n<th><code>prototype</code></th>\r\n</tr>\r\n</thead>\r\n<tbody>\r\n<tr>\r\n<td>普通对象</td>\r\n<td>✅</td>\r\n<td>❌</td>\r\n</tr>\r\n<tr>\r\n<td>函数对象</td>\r\n<td>✅</td>\r\n<td>✅</td>\r\n</tr>\r\n</tbody>\r\n</table><p>所以，请你先记住以下结论：</p><ul><li>\r\n只有函数对象有 prototype 属性，普通对象 没有这个属性。\r\n</li><li>\r\n函数对象 和 普通对象 都有 __proto__这个属性。\r\n</li><li>\r\nprototype 和  __proto__都是在创建一个函数或者对象会自动生成的属性。\r\n</li></ul><p>接着我们来验证一下:</p><pre><code>function func (){  //func称为构造函数\r\n\r\n}\r\nconsole.log( typeof func.prototype); // object\r\nconsole.log(typeof func.__proto__);  // function\r\n复制代码</code></pre><pre><code>const obj = {}\r\nconsole.log(typeof obj.__proto__) //object\r\nconsole.log(typeof obj.prototype) //undefined （看见了吧，普通对象真的没有 prototype 属性）\r\n复制代码</code></pre><p>所以就验证了我们刚刚的结论：</p><ul><li>只有函数对象有 prototype 属性，普通对象 没有这个属性</li><li>函数对象 和 普通对象 都有 __proto__这个属性。</li><li>prototype 和  __proto__都是在创建一个函数或者对象会自动生成的属性。</li></ul><p>你看我又重复写了一遍，我不是为了凑字数，是为了你加深记忆，这对于我们接下来的篇幅很重要。\r\n接着我们来看看下面的代码:</p><pre><code>console.log(obj.__proto__ === Object.prototype); // true\r\nconsole.log(func.__proto__ === Function.prototype); // true\r\n复制代码</code></pre><p>所以我们又得出如下结论:</p><ul><li>实例的 __proto__属性主动指向构造的 prototype;</li><li>prototype 属性被 __proto__ 属性 所指向。</li></ul><p>这就是prototype 属性和 __proto__ 属性的区别与联系。\r\n这可能又有点绕了，来多看几遍这一节，多背一下我们的结论。我们继续。\r\n那么问题来了，既然func是一个函数对象，函数对象是有 prototype 属性的，那么func.prototype.__proto__等于啥呢？\r\n为了解决这个问题，我们来思考一下：\r\n首先，我们看看func.prototype 是啥:</p><pre><code> console.log(typeof func.prototype); //object\r\n复制代码</code></pre><p>好，我们知道了，func.prototype  是一个对象，那既然是对象，那 func.prototype 那不就是 Object的实例吗？那也就是说，func.prototype.__proto__属性肯定是指向 Object.prototype 咯！\r\n好，我们来验证一下:</p><pre><code> console.log(func.prototype.__proto__ === Object.prototype); //true\r\n复制代码</code></pre><p>看见没有，就是这样的。那看到这里，我们应该也知道当我们这创建一个构造函数的时候，javascript是如何帮我们自动生成__proto__和prototype属性的。哈哈没错就是这样:</p><pre><code>//我们手动创建func函数\r\nfunction func() {}\r\n//javascript悄悄咪咪执行以下代码:\r\nfunc._proto = Function.prototype; //实例的 __proto__ 属性主动指向构造的 prototype\r\nfunc.prototype = {\r\n    constructor: func,\r\n    __proto: Object.prototype //我们刚刚才在上面验证的，你别又忘记了\r\n}\r\n复制代码</code></pre><p>我还专门为你画了个图(够贴心不老铁):</p><figure><img alt=\"原型.png\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1013&quot; height=&quot;749&quot;></svg>\"><figcaption></figcaption></figure><p>所以prototype又被称为显式原型对象，而__proto__又被称为隐式原型对象。</p><p>hi，看到这里，你是不是有种脑子开了光的感觉。哈哈，所以到现在你应该已经理解原型的概念了，如果你还不理解，那就把上述章节再看一遍。最好拿个纸笔出来跟着画一画，顺便拿出电脑把示例代码敲一敲。好，整理一下头脑，接下来我们来看看什么又是原型链。</p><h3>原型链</h3><p>再介绍这个概念之前，我们先来看如下代码：</p><pre><code>function Person = function(name,desc){\r\n    this.name = name;\r\n    this.desc = desc;\r\n} //***1****//\r\nPerson.prototype.getName = function(){\r\n    return this.name;\r\n}//***2****//\r\nPerson.prototype.getDesc = function(){\r\n    return this.desc;\r\n}//***3****//\r\n\r\nconst obj = new Person(\'juefei\',\'cool\');//***4****//\r\nconsole.log(obj);//***5****//\r\nconsole.log(obj.getName);//***6****//\r\n复制代码</code></pre><p>接下来我们来逐步解析一下:</p><ol><li>创建了一个构造函数 Person，此时，Person.portotype自动创建，其中包含了 constructor 和 __proto__两个属性;</li><li>给对象 Person.prototype 新增了一个方法 getName;</li><li>给对象 Person.prototype 新增了一个方法 getDesc;</li><li>根据构造函数 Person 新建一个实例: obj（在创建实例的时候，构造函数会自动执行）;</li><li>打印实例 obj :</li></ol><pre><code>{\r\n    name: \'juefei\',\r\n    desc: \'cool\'\r\n}\r\n复制代码</code></pre><p>根据上面一节的结论，我们得出：</p><pre><code>obj.__proto__ = Person.prototype;\r\n复制代码</code></pre><ol><li>执行到第6步时，由于在实例 obj 上面找不到  getName()这个方法，所以它就会自动去通过自身的 __proto__ 继续向上查找，结果找到了 Person.prototype ，接着它发现，刚好 Person.prototype 上面有getName()方法，于是找到了这个方法，它就停止了寻找。\r\n怎么样，是不是有一种环环相扣的感觉？他们形成一个链了，没错，这就是原型链。</li></ol><p>我们得出如下结论:\r\n在访问一个对象(假设这个对象叫obj)的属性/方法时，若在当前的对象上面找不到，则会尝试通过obj.__proto__去寻找，而 obj.__proto__ 又指向其构造函数(假设叫objCreated)的 prototype，所以它又自动去 objCreated.prototype 的属性/方法上面去找,结果还是没找到，那么就访问 objCreated.prototype.__proto__继续往上面寻找，直到找到,则停止对原型链对寻找，若最终还是没能找到，则返回 undefined 。\r\n一直沿着原型链寻找下去，直到找到 Object.prototype.__proto__,指向 null，于是返回 undefined了。</p><p>是不是自然而然就理解了。我又给你画了个图（请对照着上面👆那个图看）：</p><figure><img alt=\"原型链.png\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;740&quot; height=&quot;974&quot;></svg>\"><figcaption></figcaption></figure><p>接下来我们再来增加一些概念：</p><ol><li>任何内置函数对象本身的 __proto__属性都指向 Function的原型对象，即： Function.prototype;</li><li>除了 Object.prototype.__proto__指向 null ,所有的内置函数对象的原型对象的 __proto__属性 ( 内置函数对象.prototype.__proto__)，都指向Object。</li></ol><p>我们得出如下终极原型链的图：\r\n</p><figure><img alt=\"原型链终极图.png\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1183&quot; height=&quot;983&quot;></svg>\"><figcaption></figcaption></figure><p>针对这个图，我最终给出我们经常看见那个原型链的图:</p><figure><img alt=\"prototype.jpg\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;611&quot; height=&quot;760&quot;></svg>\"><figcaption></figcaption></figure><p>好好对比一下，拿出纸和笔画一画，根据上面章节的讲解，相信你很容易就能明白。</p><h3>javascript中的类</h3><p>刚刚我们终于明白什么是 原型 和 原型链。下面我们根据上面的概念来讲解一下javascript中的类。\r\n我们知道，在面向对象的语言中，类可以被实例化多次，这个实例化是指我们可以根据构造函数去独立复制多个独立的实例，这些实例之间是独立的。但是实际上在 javascript 却不是这样的，因为它不是这种复制机制。我们不能创建一个类的多个实例，我们只能创建这个类的多个对象，因为他们都是通过原型和原型链关联到同一个对象。所以在 javascript 中 ,类都是通过原型和原型链来实现的，它其实是一种委托方式。</p><h3>new的实现</h3><p>了解了上面javascript中的类的概念，那我们应该很容易就理解new的过程，其核心无非就是执行原型链的链接:</p><pre><code>function myNew(Cons,...args){\r\n    let obj = {};\r\n    obj.__proto__ = Cons.prototype; //执行原型链接\r\n    let res = Cons.call(obj,args);\r\n    return typeof res === \'object\' ? res : obj;\r\n}\r\n复制代码</code></pre><h3>instanceof的实现</h3><p>那么学习了原型和原型链，instanceof的实现肯定也很简单了，它也是通过原型和原型链来实现的:</p><pre><code>  function myInstanceof(left,right){\r\n      let rightProto = right.prototype;\r\n      let leftValue = left.__proto__;\r\n      while(true){\r\n          if(leftValue === null){\r\n              return false;\r\n          }\r\n          if(leftValue === rightProto){\r\n              return true;\r\n          }\r\n          leftValue = leftValue.__proto__;\r\n      }\r\n  }\r\n复制代码</code></pre><p>我就不讲解过程了，因为我知道你肯定能看懂，哈哈。</p><h3>javascript的继承</h3><p>我们都知道继承也是通过原型和原型链来实现的，那我在这里介绍两种常见的继承方式:</p><ol><li>组合继承:</li></ol><pre><code>//组合式继承\r\n//通过call继承Parent的属性，并传入参数\r\n//将Child的原型对象指向Parent的实例，从而继承Parent的函数\r\n function Parent(value){\r\n     this.val = value;\r\n }\r\n Parent.prototype.getValue = function(){\r\n     console.log(this.val);\r\n }\r\n function Child(value){\r\n     Parent.call(this,value);//继承Parentd的属性\r\n }\r\n Child.prototype = new Parent();\r\n复制代码</code></pre><ol><li>寄生组合式继承:</li></ol><pre><code>//寄生组合式继承\r\n//通过call继承Parent的属性，并传入参数\r\n//通过Object.create()继承Parent的函数\r\n  function Parent(value){\r\n      this.val = value;\r\n  }\r\n  Parent.prototype.getValue = function(){\r\n      console.log(this.val);\r\n  }\r\n  function Child(value){\r\n      //继承Parentd的属性\r\n      Parent.call(this,value);\r\n  }\r\n  Child.prototype = Object.create(Parent.prototype,{\r\n      constructor:{\r\n          value:Child,\r\n          writable:true,\r\n          configurable:true,\r\n          enumerable:false\r\n      }\r\n  })\r\n复制代码</code></pre><h3>总结</h3><ol><li>若 A 通过 new 创建了 B,则 B.__proto__ = A.prototype；</li><li>执行B.a，若在B中找不到a，则会在B.__proto__中，也就是A.prototype中查找，若A.prototype中仍然没有，则会继续向上查找，最终，一定会找到Object.prototype,倘若还找不到，因为Object.prototype.__proto__指向null，因此会返回undefined；</li><li>原型链的顶端，一定有 Object.prototype.__proto__ ——&gt; null。</li></ol><p>由此可见，原型和原型链是如此的强大，希望看完这篇文章，你不再会对他们感到恐惧。\r\n写完这篇已经近凌晨两点，如果你觉得这篇文章对你有些许收获，请点赞支持！！</p><p>参考资料:\r\n&lt;&lt; 你不知道的javascript 上卷 &gt;&gt;</p><p><br></p><p>作者：觉非</p><p><br></p><p>链接：https://juejin.im/post/5dcc3840e51d4510912421fd</p><p><br></p><p>来源：掘金</p><p><br></p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><br></p>', '2019-11-15 07:04:13', '2019-11-15 07:04:13');
INSERT INTO `articles` VALUES (7, NULL, '9个项目助你在2020年成为前端大神！', '<p>DEV的年度热文，读完觉得不错，所以翻译出来供大家参考，个人水平有限，文中可能会有一些翻译错误，可以在评论区指正。</p><p>本篇文章一共涉及了9个流行的框架/库，没有具体的介绍使用方法，而是给了一些非常棒的实战教程。</p><p>初学者(也许一些有经验的开发者也是一样)在读完官方文档，想写一个项目练手的时候不知道做什么项目好，或是有想法，但是无从下手。那么这篇文章将会给你带来很大的帮助。</p><blockquote>\r\n本篇翻译已征得原作者同意：\r\n</blockquote><figure><img src=\"https://user-gold-cdn.xitu.io/2019/11/6/16e3e822a7f3ea92?imageView2/0/w/1280/h/960/format/webp/ignore-error/1\"><figcaption></figcaption></figure><p>更多文章可戳: <a target=\"_blank\" href=\"https://github.com/YvetteLau/Blog\">github.com/YvetteLau/B…</a></p><h3>导读</h3><p>无论你是编程新手还是经验丰富的开发人员。在这个行业中，我们不得不一直学习新概念和新语言或是框架，才能跟上快速变化。以React为例 —— FaceBook 四年前开源，现在它已经成为了全球JS开发者的首选。但是与此同时，Vue 和 Angular 也有自己的追求者。然后是 Svelte，Next 和 Nuxt.js，Gatsby，Gridsome,quasar 等等，如果你想成为专业的 JavaScript 开发人员，你在使用自己熟悉的框架进行开发的同时，还需要对不同的框架和库有一些了解。</p><p>为了帮助你在2020年成为一个前端大神，我收集了9个使用了不同JS框架/库的项目，你可以去构建或者将他们加入到自己未来的开发计划中。记住，没什么比实际开发一个项目更有帮助。所以，不要犹豫，试着去开发一下。</p><h3>1. 使用React(with hooks)构建一个电影搜索应用</h3><p>首先，你可以使用React构建一个电影搜索应用。展示如下：</p><figure><img src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;473&quot;></svg>\"><figcaption></figcaption></figure><h4>你将学到什么？</h4><p>构建这个项目，你可以使用较新的 Hook API 来提升你的 React 技能。示例项目使用了React组件，很多 hooks 以及一些外部的 API，当然还有一些CSS样式。</p><h4>技术栈/点</h4><ol><li>React(Hooks)</li><li>create-react-app</li><li>JSX</li><li>CSS</li></ol><p>你可以在这里看到这个示例项目：<a target=\"_blank\" href=\"https://www.freecodecamp.org/news/how-to-build-a-movie-search-app-using-react-hooks-24eb72ddfaf7/\">www.freecodecamp.org/news/how-to…</a></p><h3>2.使用Vue构建一个聊天应用</h3><p>另外一个要介绍给你的很棒的项目是使用Vue构建的聊天应用程序。展示如下：</p><figure><img src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;880&quot; height=&quot;581&quot;></svg>\"><figcaption></figcaption></figure><h4>你将学到什么？</h4><p>您将学习到如何从头开始设置Vue应用，创建组件，处理状态，创建路由，连接到第三方服务，甚至是处理身份验证。</p><h4>技术栈/点</h4><ol><li>Vue</li><li>Vuex</li><li>Vue Router</li><li>Vue CLI</li><li>Pusher</li><li>CSS</li></ol><p>这真的是一个非常棒的项目，不管是用来学习Vue或者是提升现有的技能，以应对2020年的发展。你可以查看这个教程： <a target=\"_blank\" href=\"https://www.sitepoint.com/pusher-vue-real-time-chat-app/\">www.sitepoint.com/pusher-vue-…</a></p><h3>3. 使用Augular8构建一款漂亮的天气应用</h3><p>此示例将帮助你使用 Google 的 Angular 8 来构建一块漂亮的天气应用程序：</p><figure><img src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;880&quot; height=&quot;495&quot;></svg>\"><figcaption></figcaption></figure><h4>你将学到什么？</h4><p>该项目将教你一些宝贵的技能，例如从头开始创建应用，从设计到开发，一直到生产就绪部署。</p><h4>技术栈/点</h4><ol><li>Angular 8</li><li>Firebase</li><li>SSR</li><li>网络布局和Flexbox</li><li>移动端友好 &&amp; 响应式布局</li><li>深色模式</li><li>漂亮的用户界面</li></ol><p>对于这个综合项目，我真正喜欢的是，不是孤立地学习东西，而是从设计到最终部署的整个开发过程。</p><p><a target=\"_blank\" href=\"https://medium.com/@hamedbaatour/build-a-real-world-beautiful-web-app-with-angular-6-a-to-z-ultimate-guide-2018-part-i-e121dd1d55e\">medium.com/@hamedbaato…</a></p><h3>4. 使用 Svelte 构建一个 To-Do 应用</h3><p>与React，Vue和Angular相比，Svelte 还很新，但仍是热门之一。好的，To-Do应用不一定是那里最热门的项目，但这确实可以帮助你提高Svelte技能，如下：</p><figure><img src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;880&quot; height=&quot;680&quot;></svg>\"><figcaption></figcaption></figure><h4>你将学到什么？</h4><p>本教程将向你展示如何从头到尾使用Svelte3制作应用。 它利用了组件，样式和事件处理程序。</p><h4>技术栈/点</h4><ol><li>Svelte 3</li><li>Components</li><li>CSS</li><li>ES6语法</li></ol><p>Svelte 没有太多优秀的入门项目，这个是我觉得不错的一个上手项目：<a target=\"_blank\" href=\"https://medium.com/codingthesmartway-com-blog/building-a-svelte-3-todo-app-from-start-to-deployment-1737f72c23a6\">medium.com/codingthesm…</a></p><h3>5. 使用 Next.js 构建购物车</h3><p>Next.js 是一个轻量级的 React 服务端渲染应用框架，该项目将向你展示如何构建一个如下所示的购物车：</p><figure><img src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1280&quot; height=&quot;727&quot;></svg>\"><figcaption></figcaption></figure><h4>你将学到什么？</h4><p>在这个项目中，你将学习如何设置 Next.js 的开发环境，创建新页面和组件，获取数据，设置样式并部署一个 next 应用。</p><h4>技术栈/点</h4><ol><li>Next.js</li><li>组件和页面</li><li>数据获取</li><li>样式</li><li>部署</li><li>SSR和SPA</li></ol><p>你可以在此处找到该教程：<a target=\"_blank\" href=\"https://snipcart.com/blog/next-js-ecommerce-tutorial\">snipcart.com/blog/next-j…</a></p><h3>6. 使用 Nuxt.js 构建一个多语言博客网站</h3><p>Nuxt.js 是 Vue 服务端渲染应用框架。你可以创建一个如下所示的应用程序：</p><figure><img src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;840&quot; height=&quot;458&quot;></svg>\"><figcaption></figcaption></figure><h4>你将学到什么？</h4><p>这个示例项目从初始设置到最终部署一步一步教你如何使用 Nuxt.js 构建一个完整的网站。它使用了 Nuxt 提供的许多出色功能，如页面和组件以及SCSS样式。</p><h4>技术栈/点</h4><ul><li>Nuxt.js</li><li>组件和页面</li><li>Storyblok模块</li><li>Mixins</li><li>Vuex</li><li>SCSS</li><li>Nuxt中间件</li></ul><p>这个项目包含了涵盖了 Nuxt.js 的许多出色功能。我个人很喜欢使用 Nuxt 进行开发，你应该尝试使用它，这将使你成为更好的 Vue 开发人员！<a target=\"_blank\" href=\"https://www.storyblok.com/tp/nuxt-js-multilanguage-website-tutorial\">www.storyblok.com/tp/nuxt-js-…</a></p><p>除此之外，我还找到了一个B站的视频：<a target=\"_blank\" href=\"https://www.bilibili.com/video/av21130191/\">www.bilibili.com/video/av211…</a></p><h3>7. 使用 Gatsby 构建一个博客</h3><p>Gatsby是一个出色的静态站点生成器，它允许使用React作为渲染引擎引擎来搭建一个静态站点，它真正具有现代web应用程序所期望的所有优点。该项目如下：</p><figure><img src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;800&quot; height=&quot;426&quot;></svg>\"><figcaption></figcaption></figure><h4>你将学到什么？</h4><p>在本教程中，你将学习如何利用 Gatsby 构建出色的博客。</p><h4>技术栈/点</h4><ol><li>Gatsby</li><li>React</li><li>GraphQL</li><li>Plugins &amp; Themes</li><li>MDX / Markdown</li><li>Bootstrap CSS</li><li>Templates</li></ol><p>如果你想创建博客，这个示例教你如何利用 React 和 GraphQL 来搭建。并不是说 Wordpress 是一个不好的选择，但是有了 Gatsby ，你可以在使用 React 的同时创建高性能站点！</p><p><a target=\"_blank\" href=\"https://blog.bitsrc.io/how-to-build-a-blog-with-gatsby-and-boostrap-d1270212b3dc\">blog.bitsrc.io/how-to-buil…</a></p><h3>8. 使用 Gridsome 构建一个博客</h3><p>Gridsome 和 Vue的关系与 Gatsby 和 React 的关系一样。Gridsome 和 Gatsby 都使用 GraphQL 作为数据层，但是 Gridsome 使用的是 VueJS。这也是一个很棒的静态站点生成器，它将帮助您创建出色的博客：</p><figure><img src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;880&quot; height=&quot;442&quot;></svg>\"><figcaption></figcaption></figure><h4>你将学到什么？</h4><p>该项目将教你如何使用 Gridsome，GraphQL 和 Markdown 构建一个简单的博客，它还介绍了如何通过Netlify 部署应用程序。</p><h4>技术栈/点</h4><ol><li>Gridsome</li><li>Vue</li><li>GraphQL</li><li>Markdown</li><li>Netlify</li></ol><p>当然，这不是最全面的教程，但涵盖了 Gridsome 和 Markdown 的基本概念，可能是一个很好的起点。</p><p><a target=\"_blank\" href=\"https://www.telerik.com/blogs/building-a-blog-with-vue-and-markdown-using-gridsome\">www.telerik.com/blogs/build…</a></p><h3>9.使用 Quasar 构建一个类似 SoundCloud 的音频播放器</h3><p>Quasar 是另一个 Vue 框架，也可以用于构建移动应用程序。 在这个项目中，你将创建一个音频播放器应用程序，如下所示：</p><figure><img src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;880&quot; height=&quot;597&quot;></svg>\"><figcaption></figcaption></figure><h4>你将学到什么？</h4><p>不少项目主要关注Web应用程序，但这个项目展示了如何通过 Quasar 框架创建移动应用程序。你应该已经配置了可工作的 Cordova 设置，并配置了 android studio / xcode。 如果没有，在教程中有一个指向quasar 网站的链接，在那里你可以学习如何进行设置。</p><h4>技术栈/点</h4><ul><li>Quasar</li><li>Vue</li><li>Cordova</li><li>Wavesurfer</li><li>UI Components</li></ul><p>一个展示了Quasar在构建移动应用程序方面的强大功能的小项目：<a target=\"_blank\" href=\"https://www.learningsomethingnew.com/how-to-build-a-sound-cloud-like-audio-player-app-with-vue-js-quasar-and-wave-surfer\">www.learningsomethingnew.com/how-to-buil…</a></p><h3>总结</h3><p>本文展示了你可以构建的9个项目，每个项目专注于一个JavaScript框架或库。现在，你可以自行决定：使用以前未使用的框架来尝试一些新的东西或是通过做一个项目来提升已有的技能，或者在2020年完成所有项目？</p><p><br></p><p>作者：刘小夕</p><p><br></p><p>链接：https://juejin.im/post/5dc0c744e51d456e7e41f5ac</p><p><br></p><p>来源：掘金</p><p><br></p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><br></p>', '2019-11-15 07:04:51', '2019-11-15 07:04:51');
INSERT INTO `articles` VALUES (8, NULL, '可能是最全的 “文本溢出截断省略” 方案合集', '<h2>前言</h2><p>在我们的日常开发工作中，文本溢出截断省略是很常见的一种需考虑的业务场景细节。看上去 “稀松平常” ，但在实现上却有不同的区分，是单行截断还是多行截断？多行的截断判断是基于行数还是基于高度？这些问题之下，都有哪些实现方案？他们之间的差异性和场景适应性又是如何？凡事就怕较真，较真必有成长。本文试图通过编码实践，给出一些答案。</p><h2>先来点基础的，单行文本溢出省略</h2><p>核心 CSS 语句</p><ul><li>overflow: hidden；（文字长度超出限定宽度，则隐藏超出的内容）</li><li>white-space: nowrap；（设置文字在一行显示，不能换行）</li><li>text-overflow: ellipsis；（规定当文本溢出时，显示省略符号来代表被修剪的文本）</li></ul><p>优点</p><ul><li>无兼容问题</li><li>响应式截断</li><li>文本溢出范围才显示省略号，否则不显示省略号</li><li>省略号位置显示刚好</li></ul><p>短板</p><ul><li>只支持单行文本截断</li></ul><p>适用场景</p><ul><li>适用于单行文本溢出显示省略号的情况</li></ul><p>Demo</p><pre><code>&lt;style&gt;\r\n    .demo {\r\n        white-space: nowrap;\r\n        overflow: hidden;\r\n        text-overflow: ellipsis;\r\n    }\r\n&lt;/style&gt;\r\n&lt;body&gt;\r\n	&lt;div class=\"demo\"&gt;这是一段很长的文本&lt;/div&gt;\r\n&lt;/body&gt;\r\n复制代码</code></pre><p>示例图片</p><figure><img alt=\"avatar\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;714&quot; height=&quot;500&quot;></svg>\"><figcaption></figcaption></figure><h2>进阶一下，多行文本溢出省略（按行数）</h2><h3>○ 纯 CSS 实现方案</h3><p>核心 CSS 语句</p><ul><li>-webkit-line-clamp: 2；（用来限制在一个块元素显示的文本的行数, 2 表示最多显示 2 行。 为了实现该效果，它需要组合其他的WebKit属性）</li><li>display: -webkit-box；（和 1 结合使用，将对象作为弹性伸缩盒子模型显示 ）</li><li>-webkit-box-orient: vertical；（和 1 结合使用 ，设置或检索伸缩盒对象的子元素的排列方式 ）</li><li>overflow: hidden；（文本溢出限定的宽度就隐藏内容）</li><li>text-overflow: ellipsis；（多行文本的情况下，用省略号“…”隐藏溢出范围的文本)</li></ul><p>优点</p><ul><li>响应式截断</li><li>文本溢出范围才显示省略号，否则不显示省略号</li><li>省略号显示位置刚好</li></ul><p>短板</p><ul><li>兼容性一般： -webkit-line-clamp 属性只有  WebKit  内核的浏览器才支持</li></ul><figure><img alt=\"avatar\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1212&quot; height=&quot;438&quot;></svg>\"><figcaption></figcaption></figure><p>适用场景</p><ul><li>多适用于移动端页面，因为移动设备浏览器更多是基于 WebKit 内核</li></ul><p>Demo</p><pre><code>&lt;style&gt;\r\n	.demo {\r\n		  display: -webkit-box;\r\n	    overflow: hidden;\r\n	    -webkit-line-clamp: 2;\r\n	    -webkit-box-orient: vertical;\r\n	}\r\n&lt;/style&gt;\r\n\r\n&lt;body&gt;\r\n	&lt;div class=\'demo\'&gt;这是一段很长的文本&lt;/div&gt;\r\n&lt;/body&gt;\r\n复制代码</code></pre><p>示例图片</p><figure><img alt=\"avatar\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;714&quot; height=&quot;500&quot;></svg>\"><figcaption></figcaption></figure><h3>○ 基于 JavaScript 的实现方案</h3><p>优点</p><ul><li>无兼容问题</li><li>响应式截断</li><li>文本溢出范围才显示省略号，否则不显示省略号</li></ul><p>短板</p><ul><li>需要 JS 实现，背离展示和行为相分离原则</li><li>文本为中英文混合时，省略号显示位置略有偏差</li></ul><p>适用场景</p><ul><li>适用于响应式截断，多行文本溢出省略的情况</li></ul><p>Demo</p><p>当前仅适用于文本为中文，若文本中有英文，可自行修改</p><pre><code>&lt;script type=\"text/javascript\"&gt;\r\n    const text = \'这是一段很长的文本\';\r\n    const totalTextLen = text.length;\r\n    const formatStr = () =&gt; {\r\n        const ele = document.getElementsByClassName(\'demo\')[0];\r\n        const lineNum = 2;\r\n        const baseWidth = window.getComputedStyle(ele).width;\r\n        const baseFontSize = window.getComputedStyle(ele).fontSize;\r\n        const lineWidth = +baseWidth.slice(0, -2);\r\n\r\n        // 所计算的strNum为元素内部一行可容纳的字数(不区分中英文)\r\n        const strNum = Math.floor(lineWidth / +baseFontSize.slice(0, -2));\r\n\r\n        let content = \'\';\r\n        \r\n      	// 多行可容纳总字数\r\n        const totalStrNum = Math.floor(strNum * lineNum);\r\n\r\n        const lastIndex = totalStrNum - totalTextLen;\r\n\r\n        if (totalTextLen &gt; totalStrNum) {\r\n            content = text.slice(0, lastIndex - 3).concat(\'...\');\r\n        } else {\r\n            content = text;\r\n        }\r\n        ele.innerHTML = content;\r\n    }\r\n    \r\n    formatStr();\r\n    \r\n		window.onresize = () =&gt; {\r\n        formatStr();\r\n    };\r\n&lt;/script&gt;\r\n\r\n&lt;body&gt;\r\n	&lt;div class=\'demo\'&gt;&lt;/div&gt;\r\n&lt;/body&gt;\r\n复制代码</code></pre><p>示例图片</p><figure><img alt=\"avatar\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;714&quot; height=&quot;500&quot;></svg>\"><figcaption></figcaption></figure><h2>再进阶一步，多行文本溢出省略（按高度）</h2><h3>○ 多行文本溢出不显示省略号</h3><p>核心 CSS 语句</p><ul><li>overflow: hidden；（文本溢出限定的宽度就隐藏内容）</li><li>line-height: 20px；（结合元素高度，高度固定的情况下，设定行高， 控制显示行数）</li><li>max-height: 40px；（设定当前元素最大高度）</li></ul><p>优点</p><ul><li>无兼容问题</li><li>响应式截断</li></ul><p>短板</p><ul><li>单纯截断文字, 不展示省略号，观感上较为生硬</li></ul><p>适用场景</p><ul><li>适用于文本溢出不需要显示省略号的情况</li></ul><p>Demo</p><pre><code>&lt;style&gt;\r\n	.demo {\r\n		overflow: hidden;\r\n		max-height: 40px;\r\n		line-height: 20px;\r\n	}\r\n&lt;/style&gt;\r\n\r\n&lt;body&gt;\r\n	&lt;div class=\'demo\'&gt;这是一段很长的文本&lt;/div&gt;\r\n&lt;/body&gt;\r\n\r\n复制代码</code></pre><p>示例图片</p><figure><img alt=\"avatar\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;714&quot; height=&quot;500&quot;></svg>\"><figcaption></figcaption></figure><h3>○ 伪元素 + 定位实现多行省略</h3><p>核心 CSS 语句</p><ul><li>\r\nposition: relative; （为伪元素绝对定位）\r\n</li><li>\r\noverflow: hidden; （文本溢出限定的宽度就隐藏内容）\r\n</li><li>\r\nposition: absolute;（给省略号绝对定位）\r\n</li><li>\r\nline-height: 20px; （结合元素高度,高度固定的情况下,设定行高, 控制显示行数）\r\n</li><li>\r\nheight: 40px; （设定当前元素高度）\r\n</li><li>\r\n::after {}  （设置省略号样式）\r\n</li></ul><p>优点</p><ul><li>\r\n无兼容问题\r\n</li><li>\r\n响应式截断\r\n</li></ul><p>短板</p><ul><li>\r\n无法识别文字的长短，无论文本是否溢出范围, 一直显示省略号\r\n</li><li>\r\n省略号显示可能不会刚刚好，有时会遮住一半文字\r\n</li></ul><p>适用场景</p><ul><li>适用于对省略效果要求较低，文本一定会溢出元素的情况</li></ul><p>Demo</p><pre><code>&lt;style&gt;\r\n    .demo {\r\n        position: relative;\r\n        line-height: 20px;\r\n        height: 40px;\r\n        overflow: hidden;\r\n    }\r\n    .demo::after {\r\n        content: \"...\";\r\n        position: absolute;\r\n        bottom: 0;\r\n        right: 0;\r\n        padding: 0 20px 0 10px;\r\n    }\r\n&lt;/style&gt;\r\n\r\n&lt;body&gt;\r\n	&lt;div class=\'demo\'&gt;这是一段很长的文本&lt;/div&gt;\r\n&lt;/body&gt;\r\n复制代码</code></pre><p>示例图片</p><figure><img alt=\"avatar\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;714&quot; height=&quot;500&quot;></svg>\"><figcaption></figcaption></figure><h3>○ 利用 Float 特性，纯 CSS 实现多行省略</h3><p>核心 CSS 语句</p><ul><li>\r\nline-height: 20px；（结合元素高度,高度固定的情况下,设定行高, 控制显示行数）\r\n</li><li>\r\noverflow: hidden；（文本溢出限定的宽度就隐藏内容）\r\n</li><li>\r\nfloat: right/left；（利用元素浮动的特性实现）\r\n</li><li>\r\nposition: relative；（根据自身位置移动省略号位置, 实现文本溢出显示省略号效果）\r\n</li><li>\r\nword-break: break-all；（使一个单词能够在换行时进行拆分）\r\n</li></ul><p>优点</p><ul><li>\r\n无兼容问题\r\n</li><li>\r\n响应式截断\r\n</li><li>\r\n文本溢出范围才显示省略号，否则不显示省略号\r\n</li></ul><p>短板</p><ul><li>省略号显示可能不会刚刚好，有时会遮住一半文字</li></ul><p>适用场景</p><ul><li>适用于对省略效果要求较低，多行文本响应式截断的情况</li></ul><p>Demo</p><pre><code>&lt;style&gt;\r\n    .demo {\r\n        background: #099;\r\n        max-height: 40px;\r\n        line-height: 20px;\r\n        overflow: hidden;\r\n    }\r\n    .demo::before{\r\n        float: left;\r\n        content:\'\';\r\n        width: 20px;\r\n        height: 40px;\r\n    }\r\n\r\n    .demo .text {\r\n        float: right;\r\n        width: 100%;\r\n        margin-left: -20px;\r\n        word-break: break-all;\r\n    }\r\n    .demo::after{\r\n        float:right;\r\n        content:\'...\';\r\n        width: 20px;\r\n        height: 20px;\r\n        position: relative;\r\n        left:100%;\r\n        transform: translate(-100%,-100%);\r\n    }\r\n&lt;/style&gt;\r\n\r\n&lt;body&gt;\r\n    &lt;div class=\'demo\'&gt;\r\n    	&lt;div class=\"text\"&gt;这是一段很长的文本&lt;/div&gt;\r\n    &lt;/div&gt;\r\n&lt;/body&gt;\r\n复制代码</code></pre><p>示例图片</p><figure><img alt=\"avatar\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;730&quot; height=&quot;494&quot;></svg>\"><figcaption></figcaption></figure><p>原理讲解</p><p>有 A、B、C 三个盒子，A 左浮动，B、C 右浮动。设置 A 盒子的高度与 B 盒子高度（或最大高度）要保持一致</p><ol><li>\r\n当的 B 盒子高度低于 A 盒子，C 盒子仍会处于 B 盒子右下方。\r\n</li><li>\r\n如果 B 盒子文本过多，高度超过了 A 盒子，则 C 盒子不会停留在右下方，而是掉到了 A 盒子下。\r\n</li><li>\r\n接下来对 C 盒子进行相对定位，将 C 盒子位置向右侧移动 100%，并向左上方向拉回一个 C 盒子的宽高（不然会看不到哟）。这样在文本未溢出时不会看到 C 盒子，在文本溢出时，显示 C 盒子。\r\n</li></ol><figure><img alt=\"yuanli.gif\" src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;730&quot; height=&quot;494&quot;></svg>\"><figcaption></figcaption></figure><h2>收，大道归简，能力封装</h2><blockquote>\r\n凡重复的，让它单一；凡复杂的，让它简单。\r\n</blockquote><p>每次都要搞一坨代码，太麻烦。这时候你需要考虑将文本截断的能力，封装成一个可随时调用的自定义容器组件。市面上很多 UI 组件库，都提供了同类组件的封装，如基于 Vue 的 ViewUI Pro，或面向小程序提供组件化解决能力的 MinUI 。</p><figure><img src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;1194&quot; height=&quot;700&quot;></svg>\"><figcaption></figcaption></figure><figure><img src=\"data:image/svg+xml;utf8,<?xml version=&quot;1.0&quot;?><svg xmlns=&quot;http://www.w3.org/2000/svg&quot; version=&quot;1.1&quot; width=&quot;940&quot; height=&quot;1280&quot;></svg>\"><figcaption></figcaption></figure><h2>结语</h2><p>本文介绍了几种目前常见的文本截断省略的方案，各有利弊，各位同学可根据实际开发情况及需求选择方案。如果你还知道更好其他实现方案，欢迎在评论区留下宝贵评论。</p><h2>参考文章</h2><ul><li><a target=\"_blank\" href=\"https://github.com/happylindz/blog/issues/12\">纯 CSS 实现多行文字截断</a></li><li><a target=\"_blank\" href=\"https://blog.csdn.net/qq_40072782/article/details/82908581\">【 CSS / JS 】限制一行和多行文字数量，溢出部分用省略号显示</a></li><li><a target=\"_blank\" href=\"https://baijiahao.baidu.com/s?id=1621362934713048315&wfr=spider&amp;for=pc\">HTML技巧篇：如何让单行文本以及多行文本溢出显示省略号(…)</a></li></ul><h2>招贤纳士</h2><p>政采云前端团队（ZooTeam），一个年轻富有激情和创造力的前端团队，隶属于政采云产品研发部，Base 在风景如画的杭州。团队现有 50 余个前端小伙伴，平均年龄 27 岁，近 3 成是全栈工程师，妥妥的青年风暴团。成员构成既有来自于阿里、网易的“老”兵，也有浙大、中科大、杭电等校的应届新人。团队在日常的业务对接之外，还在物料体系、工程平台、搭建平台、性能体验、云端应用、数据分析及可视化等方向进行技术探索和实战，推动并落地了一系列的内部技术产品，持续探索前端技术体系的新边界。</p><p>如果你想改变一直被事折腾，希望开始能折腾事；如果你想改变一直被告诫需要多些想法，却无从破局；如果你想改变你有能力去做成那个结果，却不需要你；如果你想改变你想做成的事需要一个团队去支撑，但没你带人的位置；如果你想改变既定的节奏，将会是“ 5 年工作时间 3 年工作经验”；如果你想改变本来悟性不错，但总是有那一层窗户纸的模糊… 如果你相信相信的力量，相信平凡人能成就非凡事，相信能遇到更好的自己。如果你希望参与到随着业务腾飞的过程，亲手推动一个有着深入的业务理解、完善的技术体系、技术创造价值、影响力外溢的前端团队的成长历程，我觉得我们该聊聊。任何时间，等着你写点什么，发给 ZooTeam@cai-inc.com</p><p><br></p><p>作者：政采云前端团队</p><p><br></p><p>链接：https://juejin.im/post/5dc15b35f265da4d432a3d10</p><p><br></p><p>来源：掘金</p><p><br></p><p>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><p><br></p>', '2019-11-15 07:05:39', '2019-11-15 07:05:39');
INSERT INTO `articles` VALUES (9, NULL, '桌面版应用程序的前世今生', '<blockquote>互联网出现之前，C/S 架构是软件产品的主流，后面渐渐地被 B/S 架构所取代（因为不需要配置客户端），但由于浏览器有刷新机制，服务器的负载等因素，C/S 架构的响应速度和流畅性是好于 B/S 架构的，所以现在软件开发的趋势是两者的融合，一般是 B/S 架构开发的产品可以非常方便地转移到 C/S 架构下。客户端（client）是 C/S 架构软件产品中重要的一部分，除了和用户交互、本地处理数据的强大功能，顺畅的体验和美观的样式也是客户端技术追求的目标。这里和大家介绍桌面版应用程序的一些历史和现在比较流行的 electron 技术。</blockquote><h2>桌面版应用程序历史</h2><p>桌面应用程序，又称为 GUI 程序。可以分为以下几个阶段：</p><ul><li>VB，上古程序员的开发工具，曾经全球第一的开发语言，拖拽式的图形化开发让它成为极佳的桌面开发工具。微软依靠其操作系统的优势，一直压制同时期的竞争对手 delphi。微策略早期应用该技术，开发了管理智能商务平台的大杀器 developer。</li><li>C++、win32API 的 MFC 方案是基于窗口中组合控件和消息传递机制。这也是 20 多年前的技术，所以 API 设计的不是很友好。几年前微软已经停止维护，简单来说它已经过时了。</li><li>Winform 微策略几年前基于该技术研发第一代的 Desktop 版本，但是从开发体验角度来说自定义、美化控件会比较麻烦。</li><li>C# .net framework，代表就是 WPF，它的原生特性是其他类库无法比拟的：High DPI、Split Screen 以及对 DirectX 的天然优势。但是并不开源，需要依赖.net 框架，还有就是启动会比较慢。Workstation Windows 的新客户端就是基于该技术研发。</li><li>Java swing/javaFx，这是一类比较大的阵营，优势是跨平台和流行开发语言 Java 的天然结合，但开发出来的界面作者个人认为并不美观。</li><li>C++ Qt，这是很多客户端跨平台的首选，因为开源、UI 库和各种功能的类库非常丰富，但是学习成本比较高。</li><li>C++ duilib，这是 windows 下开源的 directUI（微软提出的分离 UI 和逻辑的思想）库，它是迎合互联网桌面软件小而美的趋势发展起来的，可能大家对它的关注度比较少。但是用它开发出的产品大名鼎鼎，比如 QQ、微信、爱奇艺等很多知名度高的软件。</li><li>Objective-c/swift cocoa，这是 mac 平台下的方案。可以方便调用底层的 API，缺点是不跨平台，文档不友好，UI 库并不丰富。现在这种方式开发的越来越少了。</li></ul><h2>基于 Web 技术的桌面应用开发</h2><p>从 B/S 和 C/S 架构逐渐融合的角度来说，基于 Web 技术进行桌面程序的开发渐渐变成了主流。因为对界面的代码部分可以做到复用。</p><p>这类技术早期的方案是用 vb 内嵌 webBrowser 控件，基于 IE 内核，正好很多网页开发也有用 activeX 的需求，但这种方式具有明显的缺陷——非常依赖于用户的环境，会因为组件缺失导致程序各种崩溃。第二类是嵌入式网页框架，这类技术主要是基于浏览器引擎实现 UI 渲染。比较典型的就是 appkit 上面 UIWebView 和 CEF（chro-mium embeded framework)。这种方法可以使用网页 HTML5+CSS 实现各种酷炫的效果，但是缺点也比较明显，就是桌面程序里面嵌入了一个类似 Chrome 的浏览器，内存的开销会比较大。</p><p>后面出现了 nwjs 和 electron，electron 相比 CEF 有了单独执行 js 的 v8 引擎，可以运行 NodeJS 来完成服务器端功能，通过和内部浏览器的 v8 引擎交互可以实现一个独立的客户端，这不同于 CEF 需要寄宿在其他程序内部。</p><h2>Electron</h2><p><img src=\"https://static001.infoq.cn/resource/image/82/71/8230406c39089c55996ec023fc553871.png\" alt=\"桌面版应用程序的前世今生\"></p><p>用 Electron 来做桌面程序开发的优势明显，相当于是完全的网页编程，有 Web 开发经验的前端开发上手非常容易。Web 开发生态广泛，开发成本低，可扩展性强，一些流行的前端框架例如 React、Angular、Vue 都可以和 electron 结合进行开发。另外它也具备和 Qt 一样跨平台的优良特性。对性能要求不高的桌面版程序来说，一份代码同时得到网页版和各个平台的桌面版，开发的效率是其他方案无法比的。可以说，这是大部分人看好的趋势。</p><h3>和 Web 开发的区别</h3><p>前端开发的一个痛点就是经常需要考虑多种浏览器之间的兼容，但是使用 electron 开发则不存在这样的问题，它只需要考虑 electron 中对应 Chrome 的版本。另一个使用 electron 解决的痛点是跨域，它可以绕过客户端直接通过 NodeJS 里的 request 通信模块发出请求，这样就无需被跨域所困扰。</p><h3>扩展能力</h3><p>node-ffi 可以在 NodeJS 环境中调用动态链接库接口。通过这种方式，我们可以把 JavaScript 方法映射到动态链接库接口，从而实现 C++ 类库的接入。</p><h3>Electron 运行原理</h3><p><img src=\"https://static001.infoq.cn/resource/image/39/47/39c7055c50f9ec4e2918c74e60f12c47.png\" alt=\"桌面版应用程序的前世今生\"></p><p>Electron 的运行机制可以从两种进程说起：主进程和渲染进程。运行 package.json 的称为主进程，它可以负责创建渲染进程（多个）。下图是一段主进程代码，主进程负责创建一个浏览器实例来加载网页。每个创建的浏览器实例都在它自己的渲染进程内返回一个 Web 页面。当 BrowserWindow 实例销毁时，相应的渲染进程也会终止。主进程负责掌管所有的 Web 页面和它们相应的渲染进程。每个渲染进程都是相互独立的，它们只关心自己所运行的 Web 页面。</p><p></p><p>复制代码</p><pre><code><table><tbody><tr><td><div></div></td><td><div>const electron = require(\'electron\');</div></td></tr><tr><td><div></div></td><td><div>const app = electron.app;</div></td></tr><tr><td><div></div></td><td><div>const BrowserWindow = electron.BrowserWindow;</div></td></tr><tr><td><div></div></td><td><div> </div></td></tr><tr><td><div></div></td><td><div>var window = null;</div></td></tr><tr><td><div></div></td><td><div> </div></td></tr><tr><td><div></div></td><td><div>app.on(\'ready\', function() {</div></td></tr><tr><td><div></div></td><td><div>  window = new BrowserWindow({width: 800, height: 600});</div></td></tr><tr><td><div></div></td><td><div>  window.loadURL(\'https://microstrategy.com\');</div></td></tr><tr><td><div></div></td><td><div>});</div></td></tr></tbody></table></code></pre><p>主进程还负责应用程序的生命周期（app 打开退出）和一些 app 事件的监听，同时负责系统底层 API 的调用。创建的渲染进程用来展示 HTML + CSS 技术编写的 Web 页面， 同时可以运行 JavaScript 实现交互，可以把渲染进程简单理解为 Chrome 上打开的一个浏览器进程。</p><p></p><p>复制代码</p><pre><code><table><tbody><tr><td><div></div></td><td><div>&lt;html&gt;</div></td></tr><tr><td><div></div></td><td><div>  &lt;body&gt;</div></td></tr><tr><td><div></div></td><td><div>  &lt;script&gt;</div></td></tr><tr><td><div></div></td><td><div>    const remote = require(\'electron\').remote;</div></td></tr><tr><td><div></div></td><td><div>    console.log(remote.app.getVersion());</div></td></tr><tr><td><div></div></td><td><div>  &lt;/script&gt;</div></td></tr><tr><td><div></div></td><td><div>  &lt;/body&gt;</div></td></tr><tr><td><div></div></td><td><div>&lt;/html&gt;</div></td></tr></tbody></table></code></pre><p>在渲染进程中是不允许调用原生 GUI 相关的 API，那是因为在网页中掌管原生 GUI 很危险，易造成内存泄露。如果你想在网页中进行 GUI 的操作，渲染进程必须向主进程传达请求，然后在主进程中完成操作。</p><p>Electron 封装了一系列自己的 API 可供主进程和渲染进程调用。可以通过如下方式获取：</p><p></p><p>复制代码</p><pre><code><table><tbody><tr><td><div></div></td><td><div>const {app, BrowserWindow, ipcMain, ... } = require(\'electron\'); // 仅主进程可用</div></td></tr><tr><td><div></div></td><td><div>const {ipcRender, remote, ... } = require(\'electron\'); // 仅渲染进程可用</div></td></tr></tbody></table></code></pre><p>主进程和渲染进程均可直接调用 NodeJS 的 API：</p><p></p><p>复制代码</p><pre><code><table><tbody><tr><td><div></div></td><td><div>node1.addEventListener(\'click\', () =&gt; {</div></td></tr><tr><td><div></div></td><td><div>   console.log(os.path.basename(\'xxxx\');</div></td></tr><tr><td><div></div></td><td><div>})</div></td></tr></tbody></table></code></pre><h3>进程通信</h3><h4>渲染进程如何向主进程发送消息</h4><p>通信本质上基于 nodeJS 的事件基础类 Event-Emitter，ipcMain 和 ipcRender 都是该类的实例，通过事件模型需要的接口方法，采用了发布 / 订阅的方式来发送和监听消息。</p><p>异步方式：</p><p></p><p>复制代码</p><pre><code><table><tbody><tr><td><div></div></td><td><div>import { ipcRender } from \'electron\'; // 在渲染进程引入 ipcRender，它是 EventEmitter 的一个实例</div></td></tr><tr><td><div></div></td><td><div>ipcRender.send(\'async\', \'I am from webview\'); // 可以异步发送</div></td></tr></tbody></table></code></pre><p>同步方式：</p><p></p><p>复制代码</p><pre><code><table><tbody><tr><td><div></div></td><td><div>import { ipcRender } from \'electron\'; // 在渲染进程引入 ipcRender</div></td></tr><tr><td><div></div></td><td><div>ipcRender.sendSync(\'sync\', \'I am sync sent from webview\'); // 同步方式</div></td></tr></tbody></table></code></pre><p>通过同步方式发送会 block 整个渲染进程，直到主进程响应。</p><p>主进程会加载 ipcMain 来进行监听。</p><p></p><p>复制代码</p><pre><code><table><tbody><tr><td><div></div></td><td><div>import { ipcMain } from \'electron\'; // 在主进程引入 ipcMain</div></td></tr><tr><td><div></div></td><td><div>ipcMain.on(\'async\', (event, info) {</div></td></tr><tr><td><div></div></td><td><div>    console.log(info);</div></td></tr><tr><td><div></div></td><td><div>});</div></td></tr></tbody></table></code></pre><p>除此以外， electron 还提供了一种简单的方案（remote 模块）来实现渲染进程和主进程的通信。这样就可以不必显示地发送消息。</p><p></p><p>复制代码</p><pre><code><table><tbody><tr><td><div></div></td><td><div>import { remote } from \'electron\'; // 在渲染进程引入 remote</div></td></tr><tr><td><div></div></td><td><div>remote.mainProcessObject.invokeMethod(); // 调用主进程才有的方法</div></td></tr><tr><td><div></div></td><td><div>});</div></td></tr></tbody></table></code></pre><h4>主进程如何向渲染进程发送消息</h4><p>主进程通过找到渲染进程对应的 browserWindow 就可以发送消息。</p><p></p><p>复制代码</p><pre><code><table><tbody><tr><td><div></div></td><td><div>constant window = BrowserWindow.fromId(global.id); // 通过 id 来进行对应</div></td></tr><tr><td><div></div></td><td><div>window.webContents.send(\'msg\', \'hello world\');</div></td></tr></tbody></table></code></pre><p>渲染进程监听：</p><p></p><p>复制代码</p><pre><code><table><tbody><tr><td><div></div></td><td><div>ipcRender.on(\'msg\', (event, info) =&gt; {</div></td></tr><tr><td><div></div></td><td><div>    console.log(info)</div></td></tr><tr><td><div></div></td><td><div>});</div></td></tr></tbody></table></code></pre><h4>渲染进程之间共享数据</h4><p>一种可行的方案是在主进程实现消息的转发。还有比较简单的方案是通过浏览器实现的 HTML API，比如 localStorage， sessionStorage 或者 IndexedDB，或者通过主进程创建全局变量 sharedObject 来实现渲染进程的数据共享。</p><p>以上是一些 electron 技术的初步介绍，有兴趣的读者可以继续阅读详细的官方文档来深入学习。目前来看 electron 不能算一个年轻的开源项目， 还有不少新的桌面替代技术在涌现（比如 miniblink)。</p><p></p><p>作者介绍：徐瑞青，高级软件工程师，毕业于鲁汶大学电子工程系。2014 年加入微策略，目前在数据 gateway 部门参与数据建模、清洗的开发工作，也参与过 Workstation 数据导入的早期开发。</p><p><br></p>', '2019-11-15 07:06:19', '2019-11-15 07:06:19');
INSERT INTO `articles` VALUES (10, NULL, '让数据库运行在浏览器里，删库再也不用跑路了', '<p>作为一名数据库技术人员，一直以来都有个梦想，希望有一个数据库能够弹性扩展（分布式）到成百上千节点的规模，易于学习和理解，可以运行在私有云，公有云，multi-cloud, kubernetes, 也能够跑在嵌入式设备（比如树莓派）上，更酷的是也能够直接运行在浏览器里，且不需要任何浏览器扩展（Extension），变成口袋数据库，就像那部电影《蚁人》。</p><p>今天，这一切都变成了现实： TiDB 可以直接运行在浏览器本地。打开浏览器，你可以直接创建数据库，对数据进行增删改查，关掉浏览器，一切都消失了。干净绿色环保。</p><p>由于 TiDB 基本兼容 MySQL 协议和语法，因此可以用熟悉的 MySQL 风格，在笔记本浏览器（我用的是 MacOS 上面的 Chrome，不确定其它浏览器是否正常) 打开&nbsp;<a href=\"https://play.pingcap.com/\" target=\"_blank\">play.pingcap.com&nbsp;</a>，可能需要几秒来加载页面，然后就能看到熟悉的 Shell 了。 现在来试试几个 SQL 语句吧！</p><p><img src=\"https://static001.infoq.cn/resource/image/34/b9/34e6c30d1e69efb02f60f061123ae7b9.gif\" alt=\"让数据库运行在浏览器里，删库再也不用跑路了\"></p><p>是不是很酷？无痛体验 SQL 的时代到了。更酷的是，这一切都运行在浏览器本地，删库再也不用跑路了。</p><p>有了这些，那么是时候给在线学习 SQL 教程的网站加点功能吧，比如看教程的同步运行 SQL 语句，这里有个简单的<a href=\"https://tour.pingcap.com/\" target=\"_blank\">演示</a>。</p><p><img src=\"https://static001.infoq.cn/resource/image/c2/b4/c21b9dde40ac68d5d272cf5c1ed177b4.png\" alt=\"让数据库运行在浏览器里，删库再也不用跑路了\"></p><p>在浏览器里面运行还有哪些好处呢？还记得你安装配置数据库的痛苦吗？从此以后，每个人随时随地都可以拥有一个数据库，再没有痛苦的安装过程，再也不用痛苦的配置参数，随时享受写 SQL 的快感。也许我们不再需要 indexdb 了，SQL 是更高级的 API，TiDB 使得「一次编写、到处运行」成了现实。</p><h2>你一定很好奇这一切是怎么实现的</h2><p>这个项目的起源是参加 TiDB Hackathon 2019 比赛 Ti-cool 团队的项目 TiDB-Wasm，是他们的努力让这一切变成了现实；</p><p>同时，Go 语言支持了 Wasm ，是近期最让人兴奋的特性之一，至此，在浏览器里运行 Go 语言编写的应用程序成为了现实；</p><p>此外，PingCAP 与社区共同努力实现了开源的分布式数据库 TiDB，这让我们可以把 TiDB 编译成 Wasm，在浏览器里直接运行生成的 Wasm 文件。</p><p>至此，在浏览器里运行一个数据库成为了现实， 如果没有记错，TiDB 好像是 Go 语言编写的第一个可以在浏览器里面运行的 SQL 数据库。</p><h2>TiDB + WebAssembly 为何如此让人兴奋？</h2><p>WASM ，全称：WebAssembly ，是一个可移植、体积小、加载快并且兼容 Web 的全新格式。</p><ul><li>Wasm 本身是一个很有野心和想象力的技术，极大的扩展了前端的能力，TiDB-Wasm 将数据库这样硬核的基础架构和炫酷的前端领域搭上关系，更进一步让用户在离线环境下就能直接体验。</li><li>这种用法是大大降低用户体验 TiDB 的成本，只需要一个浏览器页面和等待下载 Binary 的时间，完全不需要安装部署，就可以体验 TiDB 基本的功能，无论是嵌入到文档中快速运行实例还是作为 Playgroud 网站让用户自由发挥，都非常合适。</li><li>从实用角度上来看，除了能成为一个浏览器中的 REPL 供配合文档快速体验和实验之外，TiDB-Wasm 甚至未来还可以作为 js 的 localStorage API 的很好的补充，为 js 生态提供一个 SQLite 之外的高性能本地数据库。</li></ul><p>诞生于 TiDB Hackathon 2019 的项目，它的出现让现场评委老师无比激动兴奋，都对它的快速落地充满了期待。</p><blockquote>“TiDB-Wasm 极大降低了用户体验 TiDB 能力和初步验证 SQL 兼容性的门槛，使用体验就像 golang playground 一样流畅，Wasm 的出现也为 TiDB 文档中心的建设提出了新的思路，也许不久的将来，TiDB 用户可以像 golang 一样，在阅读文档的同时，就能够在页面上尝试实际操作的体验。我们也期待 Wasm 能够持续发展，实现 TiKV 的沙箱化运行，提供更贴近真实运行场景的 playground，甚至在自动化运维管理方向上贡献更新奇思路。”——李凯（美团 | 数据库团队负责人）“刚看到这个项目的时候真的眼前一亮，这是一个非常酷的创意，而且真的对 DBA 运维管理 TiDB 有非常大的帮助，个人强烈希望这个项目能尽快落地支持！目前我们公司使用 TiDB 时，有很大一部分是由现在业务改造接入，但是面临的一个很重要的问题是 应用原来都是基于 MySQL 开发，虽然 TiDB 在 SQL 语法兼容上做了很多的工作，但是仍然未能 100% 覆盖，所以业务切换前我们都必须要进行 SQL 语法兼容性测试及数据准确性校验。由于 TiDB 的部署都是在线上服务器，基于数据安全，我们的生产和办公网环境是隔离的，要实现上面的需求，目前我们有如下几种方式：a) 研发同学自己写脚本连接查看；b)DBA 登录集群协助验证；c) 开发专用查询平台支持。目前这这几种方式都不够安全且效率低下。随着我们维护的 TiDB 集群越来越多，DBA 的对这种低效工作不堪其烦，急需相关工具支持，而 TiDB-Wasm 无疑会解决这种问题，所以希望官方能够重视这个项目，并尽快落地实现。”——于伯伟（58 集团 | 数据库高级经理）“Wasm 是一个神奇的技术，也许诞生初期的目的只是为了解决 js 运行速度以及其他语言如何操作 html 的问题，但现在大家在用这种技术广泛尝试各种可能。TiDB-Wasm 就是一个很好的尝试，不仅大幅度降低了新人使用 TiDB 的难度、也给文档展示提供了神奇的操作环境、还能大幅度降低应用开发者本机调试环境的构建难度。相信这个思路能给其他服务端的软件一个很好的启发。”——李道兵（京东云 | 高级总监）“很多用户希望初步了解 TiDB 但是苦于找不到简单即用的线下环境，这导致他们还未入门就已经放弃。TiDB-Wasm 有望彻底解决这个问题。基于 TiDB-Wasm，用户可以方便的开启 session 来探索 TiDB 的特性和功能，调试 TiDB 的行为，以及对比 TiDB 与 MySQL 等数据库在 SQL 语法、加锁行为、事务隔离等级等细节上的差异，从而帮助用户更深入的理解 TiDB。对官方而言，甚至可以把路由、计算、存储层的扩容缩容、迁移等最佳实践集成到该平台并可视化该过程，从而给用户更真实、直观的感受。这将是一款令人激动的产品，它将促进 TiDB 社区更加繁荣，也将让所有 TiDB 用户受益！”——赵应钢（美团点评 | 分布式数据库平台开发和运维负责人，研究员）“TiDB-Wasm 这个项目成功地将 TiDB 移植到了 Wasm，证明了 TiDB 编译到 Wasm 的可行性，同时也反映了 WebAssembly 已走向成熟，相信后面会有更多项目移植到浏览器里运行。目前项目还处于 demo 阶段，后续如果将项目继续落地，在上面添加更多功能，比如使用 indexedDB 让数据持久化，比如使用 webrtc 之类的技术让不同浏览器中的 TiDB 可以进行 P2P 通讯，实现分布式浏览器数据库，我非常期待这些实现。”——侯圣文（贝壳找房 | 数据技术总监）</blockquote><p>接下来让我们试试更多有趣的想法:</p><ul><li>让更多的在线 SQL 教程都可以直接运行。</li><li>让 TiDB 运行在 go play ground 上，或许需要 Go team 的帮助。</li><li>支持持久化数据库，我们已经有了云计算，边缘计算，为什么不能有浏览器计算呢？</li></ul><p></p><p>如果你有新的，有趣的想法，欢迎联系 TiDB 技术团队。</p><p><br></p>', '2019-11-15 07:06:44', '2019-11-15 07:06:44');
INSERT INTO `articles` VALUES (11, NULL, '在2019年学习如何成为现代前端开发人员', '<blockquote>我已经为新的一年重新编写和替换了这篇文章，使其变得更简洁以及更易于遵循一些推荐的练习，如果你发现和之前读过的版本有一些小小的出入或者一些矛盾的评论请不要苦恼。前几年的版本可以在GitHub archives里找到</blockquote><p>Web开发是一个不断变化的领域——今天我们建立网站的方式和几年前我们习惯的方式已经完全不同了。过剩的现有工具以及每天都会出现的新工具，大多数时候开发者都受困于应该采用哪种工具去实现目的。</p><p><img src=\"https://cdn-images-1.medium.com/max/1600/0*9ZHfE4icf5Cnpqh6\" alt=\"\"></p><p>我是“<a href=\"https://github.com/kamranahmedse/developer-roadmap\">开发者路线图</a>” 的作者和维护者，其中列出了您希望学习和进入前端、后端和操作系统的路线图、工具和技术。 我在&nbsp;<a href=\"https://github.com/kamranahmedse/developer-roadmap/tree/ee2b3e5de0e2a9ccccf3f2bbe4687f150df976f4\">2017年</a>创建了这个路线图，然后在&nbsp;<a href=\"https://github.com/kamranahmedse/developer-roadmap/tree/67a72aab113e79c11e292ada394606f079f6a263\">2018年</a>做了更新，并且在最近做了<a href=\"https://github.com/kamranahmedse/developer-roadmap\">2019年</a>修订版。 在写这篇文章的时候，前端开发者路线图已经对最近几年做了更新。我仍然还在写后段和操作系统的路线图希望能在未来的几天里发布。</p><p>路线图github地址：<a href=\"https://github.com/kamranahmedse/developer-roadmap\">kamranahmedse/developer-roadmap&nbsp;Roadmap to frontend, backend or operations in 2019.&nbsp;github.com</a><a href=\"https://github.com/kamranahmedse/developer-roadmap\"></a></p><p>在这篇文章中，我将回顾一下，与你分享制作这些路线图背后的动机，如果你决定遵循这些路线图，最后有一些分类和提示，虽不能保证，但也提供了如何在2019年成为紧跟时代的前端开发者的方法。</p><h3>动机</h3><p>在开始这篇文章之前先让你对我有个了解为，我在过去的六年里一直在进行着全栈开发目前在&nbsp;<a href=\"http://tajawal.com/\">tajawal</a>&nbsp;担任首席工程师，在这里作为工作的一部分我必须扮演不同角色。 这不仅是我的爱好，也是我的工作职责之一，要密切关注趋势，接受技术决策并保持开发人员的积极性和训练。</p><p>Web开发增进了很多，并且进化的很快；前端可供选择的数量足够困扰任何人。我在开源社区非常活跃；如果每次在论坛上被问到或者看到有人提问“接下去我该学什么”这样的问题我都能拿到一便士，那么我早在几年前就可以退休了。 大约2017年，我的一位大学教授正在为她的学生准备一套路径让他们了解市场，并希望我提供一份工具清单和网络开发技术建议。我记下粗略的草图并转发给她，但后来我决定将它删掉并把它放在GitHub上，以便每当我被问到这个问题时我都可以推荐任何人。这就是这些路线图诞生的初衷。</p><h3>免责声明</h3><p>在开始跟随路线图之前，请记住这些免责声明。</p><blockquote>这份路线图的目的是让你对前端有个整体的概念，并且当你产生困惑时指导你下一步应该学什么，而不是为了追赶潮流去学新的技术。你应该逐渐理解为什么一个工具比另一个工具更适合某些场景，并记住最新的工具并不意味着最适合这个场景</blockquote><p>其次，研究下你的就业市场</p><blockquote>不要忽视语言和工具可能非常依赖于市场这一事实，因此请对你的目标市场做一些研究。</blockquote><p>再者，你没必要去知道文章里列出的所有内容。</p><blockquote>你不需要了解这里列出的所有内容即可获得第一份工作。假如你刚进入web开发这个行业不要被这份路线图吓到，即使它看上去巨大无比。因为我试图把你最终会学到乃至用到的所有相关技术都涵盖到这份路线图中。你可以先学习最低限度，并在开始构建东西的时候继续学习其余部分。</blockquote><h3>第一阶段——准备工作</h3><p>如果你是一个刚步入前端的初学者，这里给你准备了一份不一样的路线图。先不要往下深入，看一下下面的初阶路线图。完成路线图中列出的项目，并在使用它们制作一些项目后再回来继续下面的阶段。</p><p><img src=\"https://cdn-images-1.medium.com/max/2400/1*O3c7w9xGtSTun-twCk6bcQ.png\" alt=\"\"></p><p>仅仅是学会列出来的项目，你就可以自称是前端开发并且在市场里找到工作。我知道很多人就是靠做这些，并从自由职业者或日常工作中获得可观的收入。花一些时间在路线图中列出的所有项目上，牢牢抓住所有这些内容并多多练习。写大量的项目。 下面列出了一些你可以做的东西。</p><h4>任务</h4><ul><li>写一个&nbsp;<a href=\"https://en.wikipedia.org/wiki/Pomodoro_Technique\">番茄时钟</a>&nbsp;应用。 你可以克隆并且创建一个&nbsp;<a href=\"https://electronjs.org/apps/pomotroid\">web版本的应用</a></li><li>用良好的响应式布局去创建一个使用<a href=\"https://developer.github.com/v3/repos/\">GitHub代码仓库接口</a>的网页项目去获取并展示本周前十的代码仓库。</li><li>创建一个<a href=\"https://cdn.dribbble.com/users/1176634/screenshots/4201939/42.jpg\">简单的todo list应用</a>&nbsp;你可以添加任务，标记他们完成，编辑和删除任务.</li><li>创建一个简单的秒表，有开始、暂停、停止和重置四个功能。</li></ul><p>一旦你做完了上面的这些任务，去学习下版本控制系统，学习git的基础用法，并且在&nbsp;<a href=\"https://github.com/\">GitHub</a>上创建你的账号。</p><p><img src=\"https://cdn-images-1.medium.com/max/1600/1*mLB_hcBwt_80GD6FzeBirw.png\" alt=\"\"></p><h3>第二阶段——写更好的CSS</h3><p>一旦你学会了基础部分，下一步就是学习如何写可维护的CSS和使用CSS框架。这里给出了一份路线图</p><p><img src=\"https://cdn-images-1.medium.com/max/1600/1*Sqvp0vYBNj0IMIdC85Z1AQ.png\" alt=\"\"></p><p>完成此步骤后，请继续对您在第1阶段中所做的项目执行以下任务</p><h4>任务</h4><ul><li>使用npm&nbsp;或者&nbsp;yarn.给之前的项目添加bootstrap库</li><li>把你第一阶段的项目改写成BEM的规范</li><li>用SASS来写CSS</li><li>使用NPM的Script把SASS自动转换成CSS</li></ul><h3>第三阶段——崛起</h3><p>这一阶段将是你迈向现代前端开发的一段时间。继续去学习更多Javascript相关的内容。了解什么是Webpack，了解不同的概念以及为什么需要它。了解什么是Babel，为什么我们使用它并学习如何集成webpack，最后学习如何使用ESLint来检查代码。这个阶段所列出的所有项目都围绕webpack。</p><p><img src=\"https://cdn-images-1.medium.com/max/1600/1*g4DSbfmaQj2UjxC8HG_wcQ.png\" alt=\"\"></p><p>你将从这个周末开始体会现代前端开发。完成这个阶段后，请继续执行一下步骤，以便更好的掌握构建工具。</p><h4>任务</h4><ul><li>创建一个npm包就收一个用户名，返回从社交网络上查到的所有链接（如果存在的话）。它应该与webpack捆绑在一起，使用babel进行转换并使用ESLint进行代码检测。</li><li>创建一个简单的待办事项应用程序，使用SASS来写CSS，为样式添加bootstap框架，使用BEM，使用babel转义Javascript，将其与webpack捆绑在一起，创建优化的生产构建并将其部署在github pages上。</li></ul><h3>第四阶段——现代前端应用</h3><p>下一步是学习一些前端框架。 有多种选择，但目前最常用的是React，Angular和Vue。 我建议你去React。</p><p>首先学习React，然后看一下redux，之后再学习JS中的CSS; 这不是必需的，但如果您愿意，可以查看Styled Components和CSS模块。</p><p><img src=\"https://cdn-images-1.medium.com/max/2400/1*i0O3tQ1YBJITGsWHjql-3A.png\" alt=\"\"></p><p>一旦你学会了React，请继续阅读有关网站渐进增强体验(PWA)的信息。现在你已经了解了前端框架，这对你来说应该不会那么困难。 查看&nbsp;<a href=\"https://developers.google.com/web/progressive-web-apps/checklist\">PWA checklist</a>,，阅读有关service workers、性能测试、使用lighthouse，查看可以使用的不同浏览器的API来增强你的应用，例如：存储、位置、通知、设备方向和付款。 另外也请阅读<a href=\"https://developers.google.com/web/fundamentals/performance/prpl-pattern/\">RAIL model</a>&nbsp;和&nbsp;<a href=\"https://developers.google.com/web/fundamentals/performance/prpl-pattern/\">PRPL pattern</a>的信息。</p><p>一旦你做完了这些，你就可以称自己是现代前端开发工程师。一定要练习你学到的东西。如果你正在寻找点子，这里是你可以选择的任务列表。</p><h4>任务</h4><ul><li>创建一个简单的应用允许你选择一些话题(#话题)，并使用&nbsp;<a href=\"https://developer.twitter.com/en/docs/tweets/search/api-reference/get-search-tweets.html\">twitter的搜索API</a>&nbsp;来获取并向你展示像trello一样的栅格布局。尝试固定主题标签，以便在用户刷新页面时，他会记住你选择的主题标签。使用react router来添加页面。</li><li>创建一个<a href=\"https://splode.github.io/pomotroid/\">与此类似的番茄钟</a>允许用户配置工作和休息的持续时间，显示通知并在工作或休息结束/开始的时候播放提示音</li><li>使用react重新创建&nbsp;<a href=\"https://github.com/trending\">github趋势页面</a>，并允许使用语言和日期过滤，就像github一样。你可以添加任何日期库。</li></ul><h3>第五阶段——自动化测试</h3><p>学习给你的应用写自动化测试将在未来为你节省下很多麻烦，并且在寻找工作时会让你处于更有利的位置。首先，学习什么是不同类型的测试，不同的概念，比如模拟，存根等。然后继续以相应的方式学习Jest，Enzyme和Cypress。同时也要学会计算测试覆盖率。</p><p><img src=\"https://cdn-images-1.medium.com/max/1600/1*U-46rJO5bDN1drQqlQDscA.png\" alt=\"\"></p><h4>任务</h4><p>对于任务，请继续为你在之前第四阶段中创建的应用编写单元、集成和功能测试。</p><h3>第六阶段——静态类型检查</h3><p>类型检查器允许你的代码在增长是更易于维护，在进行重构时提高灵活性，这在IDE中提供了更好的支持，并且是你可以拥有的最佳文档形式。这个领域里面主要有Flow和TypeScript，TypeScript有更多的进展，我推荐你使用它。</p><p><img src=\"https://cdn-images-1.medium.com/max/1600/1*JSMH5nDPc_iE-Gy7sgBVdQ.png\" alt=\"\"></p><p>完成学习TypeScript后，使用TypeScript转换现有的Javascript应用。</p><h3>第七阶段——服务端渲染（SSR）</h3><p>与客户端渲染相比，服务器渲染允许更好的SEO（搜索引擎优化）表现. 虽然不是必须的，但它肯定会帮助你制作更好的前端应用。根据你选择的前端框架，有不同的选项可供选择；如果你选择了React.js那么你应该使用Next.js，这使SSR变得轻而易举。</p><p><img src=\"https://cdn-images-1.medium.com/max/1600/1*mHhTLRM3W0uAcAWrX3_S8A.png\" alt=\"\"></p><p>关于任务，请用Next.js将你之前创建的任何应用转换成服务端渲染</p><h3>第八阶段——更加深入</h3><p>这一阶段显示的所有内容都是可选的，而非必须的。如果你想尝试一下，请继续往下看。</p><p><img src=\"https://cdn-images-1.medium.com/max/1600/1*vu3rRYsjWdklJjRDHUgXIQ.png\" alt=\"\"></p><p>请注意，为了简洁起见，我没有深入细节而是试图给你一个更大的视角； 你学习的时候需要自己去弄清楚其中的细节。</p><h3>完整的路线图</h3><p>下面给出了整个路线图的完整图表，其中包含了一些其他详细信息。</p><p><img src=\"https://cdn-images-1.medium.com/max/2400/1*DfKcPCa8GWVvWC61P2eBRg.png\" alt=\"\"></p><p>路线图中可能仍然缺少一些东西，但这就是你对“前端工程”角色所需要的全部内容。记住关键的要尽可能多的练习。它可能在开始时看起来十分可怕，你会觉得你没有抓住很多要点，但这是正常的，随着时间的推移，你会变得你越来越好。如果你遇到困难，不要忘记寻求帮助，你会惊讶于有多少人愿意提供帮助。</p><p></p><p>可以通过我的GitHub简介找到此路线图以及后端和操作路线图。 请注意，我仍在努力升级Backend和DevOps，并计划在未来几天内发布它们。</p><p><br></p>', '2019-11-16 09:47:38', '2019-11-16 09:47:38');

-- ----------------------------
-- Table structure for users
-- ----------------------------
DROP TABLE IF EXISTS `users`;
CREATE TABLE `users`  (
  `id` bigint(20) UNSIGNED NOT NULL AUTO_INCREMENT,
  `username` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `password` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  `email` varchar(255) CHARACTER SET utf8mb4 COLLATE utf8mb4_0900_ai_ci NULL DEFAULT NULL,
  PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB AUTO_INCREMENT = 8 CHARACTER SET = utf8mb4 COLLATE = utf8mb4_0900_ai_ci ROW_FORMAT = Dynamic;

-- ----------------------------
-- Records of users
-- ----------------------------
INSERT INTO `users` VALUES (1, 'Jacky', '123', 'jacky@abc.com');
INSERT INTO `users` VALUES (6, 'admin', '456', 'gzccsa@126.com');

SET FOREIGN_KEY_CHECKS = 1;
